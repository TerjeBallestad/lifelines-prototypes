---
phase: 04-activities-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/entities/types.ts
  - src/entities/Activity.ts
autonomous: true

must_haves:
  truths:
    - "Activity types can be imported and used"
    - "Activity class can be instantiated with data"
    - "Activity tracks mastery level and XP"
    - "Activity has capacity profile for success calculation"
  artifacts:
    - path: "src/entities/types.ts"
      provides: "ActivityData, DurationMode, ActivityState, CapacityKey types"
      contains: "ActivityData"
    - path: "src/entities/Activity.ts"
      provides: "Activity class with mastery system"
      exports: ["Activity"]
  key_links:
    - from: "src/entities/Activity.ts"
      to: "src/entities/types.ts"
      via: "type imports"
      pattern: "import.*ActivityData.*types"
---

<objective>
Create Activity entity class and type definitions for the activity system.

Purpose: Establish the data model for activities that players assign to characters, including duration modes, resource effects, capacity profiles for success calculation, and mastery progression.
Output: Activity.ts entity class and type definitions in types.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-activities-system/04-CONTEXT.md
@.planning/phases/04-activities-system/04-RESEARCH.md
@src/entities/types.ts
@src/entities/Skill.ts
@src/entities/Character.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add activity types to types.ts</name>
  <files>src/entities/types.ts</files>
  <action>
Add the following types to the existing types.ts file (after the skill types):

1. CapacityKey type (type-safe access to Capacities):
   `export type CapacityKey = keyof Capacities;`

2. DurationMode discriminated union:
   - `{ type: 'fixed'; ticks: number }` - fixed duration activities (eating)
   - `{ type: 'threshold'; resource: ResourceKey; target: number }` - until resource reaches target (sleeping until energy >= 80)
   - `{ type: 'variable'; baseTicks: number }` - affected by mastery

3. ActivityState type: 'queued' | 'starting' | 'active' | 'completed' | 'failed'

4. ActivityData interface:
   - id: string
   - name: string
   - description: string
   - domain: SkillDomain
   - durationMode: DurationMode
   - resourceEffects: Partial<Record<ResourceKey, number>> (negative = drain, positive = restore)
   - capacityProfile: Partial<Record<CapacityKey, number>> - target capacity values for success calculation (e.g., { attentionSpan: 60, workingMemory: 50 } means activity wants these capacity levels for optimal success)
   - baseXPRate: number (domain XP per tick)
   - startRequirements: optional object with minOverskudd, minEnergy thresholds

Keep existing types unchanged. Add new types at the bottom before the closing comment.
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>DurationMode, ActivityState, ActivityData, CapacityKey types exported from types.ts with capacityProfile field</done>
</task>

<task type="auto">
  <name>Task 2: Create Activity entity class</name>
  <files>src/entities/Activity.ts</files>
  <action>
Create Activity.ts following the Character/Skill pattern:

1. Import makeAutoObservable from mobx
2. Import ActivityData, SkillDomain, ResourceKey, CapacityKey, DurationMode from ./types

3. Activity class with:
   - Readonly static properties from ActivityData: id, name, description, domain, durationMode, resourceEffects, capacityProfile, baseXPRate, startRequirements
   - Mutable mastery properties: masteryLevel (1-10, starts at 1), masteryXP (starts at 0)

4. Constructor that takes ActivityData and assigns all fields, calls makeAutoObservable(this)

5. Computed getters:
   - `masteryBonus`: number - (masteryLevel - 1) * 0.05 (0-45% bonus at levels 1-10)
   - `masteryDrainReduction`: number - (masteryLevel - 1) * 0.03 (0-27% at levels 1-10)
   - `masterySpeedBonus`: number - (masteryLevel - 1) * 0.02 (0-18% at levels 1-10)
   - `domainXPMultiplier`: number - 1 - (masteryLevel - 1) * 0.1 (100% at L1, 10% at L10)
   - `nextMasteryXPRequired`: number - Math.floor(100 * Math.pow(masteryLevel + 1, 1.5)), Infinity if masteryLevel >= 10

6. Action methods:
   - `addMasteryXP(amount: number)`: Add XP, auto-level up if threshold reached (cap at 10)

Follow the class structure and MobX patterns from Skill.ts. Use `readonly` for immutable properties assigned in constructor.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>Activity class can be instantiated with data, has mastery calculations, includes capacityProfile, uses makeAutoObservable</done>
</task>

</tasks>

<verification>
```bash
# TypeScript compilation check
npx tsc --noEmit

# Verify Activity can be imported
npx tsx -e "import { Activity } from './src/entities/Activity'; console.log('Activity class OK');"

# Verify types exported
npx tsx -e "import { ActivityData, DurationMode, ActivityState, CapacityKey } from './src/entities/types'; console.log('Types OK');"
```
</verification>

<success_criteria>
- TypeScript compiles without errors
- Activity class follows Character/Skill MobX pattern
- DurationMode has all three variants (fixed, threshold, variable)
- ActivityData interface matches RESEARCH.md specification plus capacityProfile
- CapacityKey type exported for type-safe capacity access
- Mastery calculations use formulas from RESEARCH.md
</success_criteria>

<output>
After completion, create `.planning/phases/04-activities-system/04-01-SUMMARY.md`
</output>
