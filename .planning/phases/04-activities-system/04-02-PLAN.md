---
phase: 04-activities-system
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/stores/ActivityStore.ts
  - src/stores/RootStore.ts
autonomous: true

must_haves:
  truths:
    - "ActivityStore can be accessed via RootStore"
    - "Activities can be enqueued and dequeued"
    - "Queue is observable and triggers React updates"
  artifacts:
    - path: "src/stores/ActivityStore.ts"
      provides: "Queue management, activity state, start checks"
      exports: ["ActivityStore"]
    - path: "src/stores/RootStore.ts"
      provides: "activityStore property and useActivityStore hook"
      contains: "activityStore"
  key_links:
    - from: "src/stores/ActivityStore.ts"
      to: "src/stores/RootStore.ts"
      via: "constructor injection"
      pattern: "constructor.*RootStore"
    - from: "src/stores/RootStore.ts"
      to: "src/stores/ActivityStore.ts"
      via: "import and instantiation"
      pattern: "new ActivityStore"
---

<objective>
Create ActivityStore with queue management and wire it to RootStore.

Purpose: Implement the MobX store that manages the activity queue, current activity state, and provides methods for queue operations (enqueue, dequeue, reorder, cancel).
Output: ActivityStore.ts integrated into RootStore with convenience hook
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-activities-system/04-CONTEXT.md
@.planning/phases/04-activities-system/04-RESEARCH.md
@src/stores/RootStore.ts
@src/stores/SkillStore.ts
@src/stores/SimulationStore.ts
@src/entities/Activity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ActivityStore</name>
  <files>src/stores/ActivityStore.ts</files>
  <action>
Create ActivityStore.ts following the SkillStore/SimulationStore pattern:

1. Imports:
   - makeAutoObservable, observable from mobx
   - Activity from ../entities/Activity
   - type RootStore from ./RootStore
   - type ActivityData, ResourceKey from ../entities/types

2. Observable state:
   - queue: observable.array<Activity>() - FIFO queue of activities
   - currentActivity: Activity | null - currently executing activity
   - currentProgress: number = 0 - ticks elapsed on current activity
   - currentState: 'idle' | 'starting' | 'active' | 'completing' = 'idle'

3. Private property: readonly root: RootStore (constructor injection)

4. Constructor:
   - Accept root: RootStore
   - Assign this.root = root
   - Call makeAutoObservable(this)

5. Queue operations (actions):
   - `enqueue(activityData: ActivityData)`: Create Activity instance, push to queue
   - `dequeue(): Activity | undefined`: shift from queue
   - `reorder(fromIndex: number, toIndex: number)`: splice + insert
   - `cancel(index: number)`: splice to remove
   - `clearQueue()`: splice(0) to empty

6. Activity check (computed/method):
   - `canStartActivity(activity: Activity): { canStart: boolean; reason?: string }`:
     - Get character from root.characterStore.character
     - Return false if no character
     - Check overskudd >= 20 (configurable threshold, use const MIN_OVERSKUDD_TO_START = 20)
     - Return { canStart: true } if passes, { canStart: false, reason: narrative message } if fails
     - Narrative format: "${character.name} doesn't have the energy to start this"

7. Computed getters:
   - `get isIdle(): boolean` - currentState === 'idle' && currentActivity === null
   - `get queueLength(): number` - queue.length
   - `get hasQueuedActivities(): boolean` - queue.length > 0 || currentActivity !== null

8. Expose root: `get rootStore(): RootStore { return this.root; }`

NOTE: Do NOT implement processTick yet - that will be added in Plan 03 when integrating with SimulationStore.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>ActivityStore has queue operations (enqueue/dequeue/reorder/cancel), canStartActivity check, observable state</done>
</task>

<task type="auto">
  <name>Task 2: Wire ActivityStore to RootStore</name>
  <files>src/stores/RootStore.ts</files>
  <action>
Update RootStore.ts to include ActivityStore:

1. Add import: `import { ActivityStore } from './ActivityStore';`

2. Add property to RootStore class: `activityStore: ActivityStore;`

3. In constructor, add after skillStore: `this.activityStore = new ActivityStore(this);`

4. Add convenience hook at bottom:
```typescript
export function useActivityStore() {
  return useRootStore().activityStore;
}
```

Follow the exact pattern used for CharacterStore, SimulationStore, SkillStore.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Verify hook works: `npx tsx -e "import { useActivityStore } from './src/stores/RootStore'; console.log('Hook exported OK');"`
  </verify>
  <done>activityStore property on RootStore, useActivityStore hook exported</done>
</task>

</tasks>

<verification>
```bash
# TypeScript compilation
npx tsc --noEmit

# Test imports work
npx tsx -e "
import { RootStore } from './src/stores/RootStore';
const root = new RootStore();
console.log('Queue length:', root.activityStore.queueLength);
console.log('Is idle:', root.activityStore.isIdle);
console.log('ActivityStore OK');
"
```
</verification>

<success_criteria>
- TypeScript compiles without errors
- ActivityStore follows SkillStore/SimulationStore MobX pattern
- Queue uses observable.array for reactivity
- canStartActivity returns narrative error messages
- useActivityStore hook exported from RootStore
- Circular dependency avoided (Activity imports types only, not stores)
</success_criteria>

<output>
After completion, create `.planning/phases/04-activities-system/04-02-SUMMARY.md`
</output>
