---
phase: 04-activities-system
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - package.json
  - src/App.tsx
  - src/stores/ActivityStore.ts
  - src/stores/SimulationStore.ts
autonomous: true

must_haves:
  truths:
    - "Toast notifications appear for activity events"
    - "Activity ticks process during simulation"
    - "Activities complete and award domain XP"
    - "Success/fail determined by character capacities vs activity profile"
    - "Failed activities award reduced XP and show failure toast"
  artifacts:
    - path: "src/App.tsx"
      provides: "Sonner Toaster component"
      contains: "Toaster"
    - path: "src/stores/ActivityStore.ts"
      provides: "processTick method with notifications and success/fail logic"
      contains: "processTick"
    - path: "src/stores/SimulationStore.ts"
      provides: "Activity tick integration"
      contains: "activityStore.processTick"
  key_links:
    - from: "src/stores/SimulationStore.ts"
      to: "src/stores/ActivityStore.ts"
      via: "tick() calls processTick()"
      pattern: "activityStore\\.processTick"
    - from: "src/stores/ActivityStore.ts"
      to: "src/stores/SkillStore.ts"
      via: "addDomainXP on completion"
      pattern: "skillStore\\.addDomainXP"
---

<objective>
Install Sonner for toast notifications and integrate activity processing into the simulation tick loop with success/fail mechanics.

Purpose: Connect ActivityStore to the simulation so activities execute over time, applying resource effects, awarding XP based on success probability (calculated from character capacities vs activity profile), and notifying the player of state changes via toast.
Output: Working tick integration with toast notifications for activity start/complete/fail, capacity-based success calculation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-activities-system/04-CONTEXT.md
@.planning/phases/04-activities-system/04-RESEARCH.md
@src/App.tsx
@src/stores/ActivityStore.ts
@src/stores/SimulationStore.ts
@src/stores/SkillStore.ts
@src/entities/Character.ts
@src/entities/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Sonner and add Toaster</name>
  <files>package.json, src/App.tsx</files>
  <action>
1. Install Sonner:
   `npm install sonner`

2. Update src/App.tsx:
   - Add import: `import { Toaster } from 'sonner';`
   - Add Toaster component inside the root div, before CharacterPanel:
     `<Toaster position="bottom-right" richColors />`

The Toaster is a single global component that handles all toast rendering. No context provider needed.
  </action>
  <verify>
npm list sonner
Dev server runs without errors: `npm run dev` (check in browser, no console errors)
  </verify>
  <done>Sonner installed, Toaster component renders in App</done>
</task>

<task type="auto">
  <name>Task 2: Add processTick with success/fail mechanics to ActivityStore</name>
  <files>src/stores/ActivityStore.ts</files>
  <action>
Add the tick processing logic to ActivityStore with capacity-based success/fail mechanics:

1. Add imports at top:
   - `import { toast } from 'sonner';`
   - Add CapacityKey to the type imports from ../entities/types

2. Add private helper methods:

```typescript
private tryStartNextActivity(): void {
  if (this.currentActivity || this.queue.length === 0) return;

  const next = this.queue[0];
  const check = this.canStartActivity(next);

  if (check.canStart) {
    this.currentActivity = this.dequeue()!;
    this.currentProgress = 0;
    this.currentState = 'active';
    toast.success(`Started: ${this.currentActivity.name}`);
  } else {
    // Skip this activity, notify, try next
    toast.error(check.reason ?? 'Cannot start activity', {
      description: `${next.name} skipped`,
      duration: 3000,
    });
    this.dequeue(); // Remove from queue
    this.tryStartNextActivity(); // Try next recursively
  }
}

private isActivityComplete(): boolean {
  const activity = this.currentActivity;
  if (!activity) return false;

  const character = this.root.characterStore.character;
  if (!character) return false;

  switch (activity.durationMode.type) {
    case 'fixed':
      return this.currentProgress >= activity.durationMode.ticks;
    case 'threshold': {
      const { resource, target } = activity.durationMode;
      return character.resources[resource] >= target;
    }
    case 'variable': {
      const baseTime = activity.durationMode.baseTicks;
      const speedBonus = 1 - activity.masterySpeedBonus;
      return this.currentProgress >= baseTime * speedBonus;
    }
  }
}

/**
 * Calculate success probability based on character capacities vs activity capacityProfile.
 * Returns 0-1 probability where:
 * - 1.0 = character capacities meet or exceed all activity requirements
 * - 0.5 = character capacities are roughly half the requirements
 * - Higher mastery level provides a bonus to success probability
 */
private calculateSuccessProbability(): number {
  const activity = this.currentActivity;
  const character = this.root.characterStore.character;
  if (!activity || !character) return 0;

  const capacityProfile = activity.capacityProfile;
  const profileEntries = Object.entries(capacityProfile) as [CapacityKey, number][];

  // If no capacity profile defined, activity always succeeds
  if (profileEntries.length === 0) return 1;

  // Calculate how well character capacities match activity requirements
  let totalRatio = 0;
  for (const [capacityKey, targetValue] of profileEntries) {
    const characterValue = character.capacities[capacityKey];
    // Ratio capped at 1.5 (exceeding requirements helps, but with diminishing returns)
    const ratio = Math.min(1.5, characterValue / targetValue);
    totalRatio += ratio;
  }

  // Average ratio across all required capacities
  const averageRatio = totalRatio / profileEntries.length;

  // Base probability: 50% at ratio 0.5, 100% at ratio 1.0+
  let baseProbability = Math.min(1, averageRatio);

  // Mastery bonus: +5% per mastery level (up to +45% at level 10)
  // This represents learned efficiency overcoming natural capacity gaps
  const masteryBonus = activity.masteryBonus;
  const finalProbability = Math.min(1, baseProbability + masteryBonus);

  return finalProbability;
}

/**
 * Determine if activity succeeds or fails based on probability.
 * Returns { success: boolean, probability: number }
 */
private rollForSuccess(): { success: boolean; probability: number } {
  const probability = this.calculateSuccessProbability();
  const roll = Math.random();
  return {
    success: roll <= probability,
    probability,
  };
}

private completeActivity(): void {
  const activity = this.currentActivity;
  if (!activity) return;

  const character = this.root.characterStore.character;
  const { success, probability } = this.rollForSuccess();

  if (success) {
    // SUCCESS: Full mastery XP, normal domain XP
    activity.addMasteryXP(10);

    toast.success(`Completed: ${activity.name}!`, {
      duration: 2000,
    });
  } else {
    // FAILURE: Reduced mastery XP (50%), reduced domain XP happens via multiplier
    activity.addMasteryXP(5); // Half XP on failure

    // Apply penalty resource effects (10% additional drain on key resources)
    if (character) {
      const penaltyDrain = 5; // Flat penalty
      character.resources.overskudd = Math.max(0, character.resources.overskudd - penaltyDrain);
      character.resources.mood = Math.max(0, character.resources.mood - penaltyDrain);
    }

    const probabilityPercent = Math.round(probability * 100);
    toast.error(`Failed: ${activity.name}`, {
      description: character
        ? `${character.name} struggled with this activity (${probabilityPercent}% success chance)`
        : `Activity failed (${probabilityPercent}% success chance)`,
      duration: 3000,
    });
  }

  this.currentActivity = null;
  this.currentProgress = 0;
  this.currentState = 'idle';
}
```

3. Add applyResourceEffects method:

```typescript
private applyResourceEffects(speedMultiplier: number): void {
  const activity = this.currentActivity;
  const character = this.root.characterStore.character;
  if (!activity || !character) return;

  for (const [key, baseEffect] of Object.entries(activity.resourceEffects)) {
    const resourceKey = key as ResourceKey;
    let effect = baseEffect! * speedMultiplier;

    // Mastery reduces drain, modestly increases restore
    if (effect < 0) {
      effect *= (1 - activity.masteryDrainReduction);
    } else {
      effect *= (1 + activity.masteryBonus * 0.5);
    }

    // Apply to character resources (clamp handled in updateResources)
    const newValue = Math.max(0, Math.min(100, character.resources[resourceKey] + effect));
    character.resources[resourceKey] = newValue;
  }
}
```

4. Add awardDomainXP method (respects success state via stored flag):

```typescript
private awardDomainXP(speedMultiplier: number): void {
  const activity = this.currentActivity;
  if (!activity) return;

  const baseXP = activity.baseXPRate * speedMultiplier;
  const adjustedXP = baseXP * activity.domainXPMultiplier;

  this.root.skillStore.addDomainXP(activity.domain, adjustedXP);
}
```

5. Add the main processTick method (public action):

```typescript
processTick(speedMultiplier: number): void {
  // Try to start next activity if idle
  if (!this.currentActivity) {
    this.tryStartNextActivity();
  }

  // Execute current activity tick
  if (this.currentActivity) {
    this.currentProgress += speedMultiplier;
    this.applyResourceEffects(speedMultiplier);
    this.awardDomainXP(speedMultiplier);

    // Check completion
    if (this.isActivityComplete()) {
      this.completeActivity();
    }
  }
}
```

Add ResourceKey and CapacityKey to imports from types.ts.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>ActivityStore has processTick with start check, resource effects, XP award, capacity-based success/fail calculation, completion with success/failure outcomes, and toast notifications</done>
</task>

<task type="auto">
  <name>Task 3: Integrate into SimulationStore tick</name>
  <files>src/stores/SimulationStore.ts</files>
  <action>
Update SimulationStore.tick() to call activityStore.processTick():

In the tick() method, add after the character update line:

```typescript
tick(): void {
  this.tickCount += 1;
  // Update character resources based on personality and simulation speed
  this.root.characterStore.character?.applyTickUpdate(this.speed);
  // Process activity queue
  this.root.activityStore.processTick(this.speed);
}
```

This ensures activities process AFTER passive character updates, so activity effects layer on top.

NOTE: Per RESEARCH.md pitfall, activity tick runs AFTER character passive update to avoid double-dipping on resource changes.
  </action>
  <verify>
TypeScript compiles: `npx tsc --noEmit`
Dev server runs: `npm run dev`
  </verify>
  <done>SimulationStore.tick() calls activityStore.processTick() after character update</done>
</task>

</tasks>

<verification>
```bash
# TypeScript compilation
npx tsc --noEmit

# Check Sonner installed
npm list sonner

# Manual test in browser:
# 1. Start dev server: npm run dev
# 2. Open browser console
# 3. Activities aren't wired to UI yet, but tick integration should work
# 4. No console errors on load
```
</verification>

<success_criteria>
- Sonner installed and Toaster renders in App
- processTick handles activity lifecycle (start, execute, complete)
- Toast notifications fire for start/skip/complete/fail events
- Resource effects apply per-tick with mastery bonuses
- Domain XP awards per-tick with diminishing returns
- Success probability calculated from character capacities vs activity capacityProfile
- Mastery level provides bonus to success probability
- Failed activities: reduced XP (50%), penalty resource drain, failure toast
- SimulationStore.tick() calls activityStore.processTick()
- No timer drift (single tick source)
</success_criteria>

<output>
After completion, create `.planning/phases/04-activities-system/04-03-SUMMARY.md`
</output>
