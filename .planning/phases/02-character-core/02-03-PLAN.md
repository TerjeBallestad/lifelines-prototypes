---
phase: 02-character-core
plan: 03
type: execute
wave: 2
depends_on: [02-01, 02-02]
files_modified:
  - src/entities/Character.ts
autonomous: true

must_haves:
  truths:
    - "Character has computed modifiers for each resource"
    - "Character has applyTickUpdate method for time-based drain/recovery"
    - "Personality affects resource drain and recovery rates"
  artifacts:
    - path: "src/entities/Character.ts"
      provides: "Character with modifier computations and tick updates"
      contains: "applyTickUpdate"
  key_links:
    - from: "src/entities/Character.ts"
      to: "src/utils/modifiers.ts"
      via: "imports modifier utilities"
      pattern: "import.*from.*modifiers"
    - from: "src/stores/SimulationStore.ts"
      to: "src/entities/Character.ts"
      via: "calls applyTickUpdate"
      pattern: "applyTickUpdate"
---

<objective>
Extend Character class with modifier computations and time-based resource updates.

Purpose: Connects personality to resource behavior, making the psychological model affect gameplay through drain/recovery mechanics.

Output:
- Character class with computed resource modifiers
- applyTickUpdate method for simulation clock integration
- Personality-to-resource mappings implemented
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-character-core/02-CONTEXT.md
@.planning/phases/02-character-core/02-RESEARCH.md
@src/entities/Character.ts
@src/entities/types.ts
@src/utils/modifiers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add personality-to-resource modifier mappings</name>
  <files>src/entities/Character.ts</files>
  <action>
Add computed properties to Character class for resource modifiers.

Import utilities:
```typescript
import {
  personalityToModifier,
  applyModifiers,
  clampResource,
  type ResourceModifier
} from '../utils/modifiers';
```

Define base drain/recovery rates as constants at file level:
```typescript
const BASE_DRAIN_RATES: Partial<Record<ResourceKey, number>> = {
  energy: 0.5,        // per tick
  socialBattery: 0.3,
  focus: 0.4,
  nutrition: 0.2,
  overskudd: 0.3,
};

const BASE_RECOVERY_RATES: Partial<Record<ResourceKey, number>> = {
  stress: 0.2,        // stress recovers (goes down) naturally
  mood: 0.1,
  motivation: 0.1,
  security: 0.05,
};
```

Add computed getters for active modifiers. Each personality trait affects specific resources:

**Extraversion:**
- Low (<50): +drain on socialBattery (introverts drain faster in social situations)
- High (>50): +recovery on mood

**Neuroticism:**
- High (>50): +drain on stress (stress builds faster)
- High (>50): -recovery on stress (harder to calm down)

**Conscientiousness:**
- High (>50): +recovery on focus
- Low (<50): +drain on motivation

**Openness:**
- High (>50): +recovery on overskudd (mental flexibility aids resilience)

**Agreeableness:**
- High (>50): +recovery on socialBattery (social situations less draining)

Create computed getter `get activeModifiers(): ResourceModifier[]` that builds this list based on current personality values.

Create computed getters for effective rates:
```typescript
get effectiveDrainRate(): (key: ResourceKey) => number {
  return (key: ResourceKey) => {
    const base = BASE_DRAIN_RATES[key] ?? 0;
    const mods = this.activeModifiers
      .filter(m => m.resourceKey === key)
      .map(m => m.drainModifier);
    return applyModifiers(base, mods);
  };
}
```
  </action>
  <verify>`npm run build` passes</verify>
  <done>Character has activeModifiers computed and effectiveDrainRate/effectiveRecoveryRate methods</done>
</task>

<task type="auto">
  <name>Task 2: Add applyTickUpdate method for simulation clock</name>
  <files>src/entities/Character.ts, src/stores/SimulationStore.ts</files>
  <action>
Add action method to Character:

```typescript
applyTickUpdate(speedMultiplier: number): void {
  // Apply drain to draining resources
  for (const [key, baseRate] of Object.entries(BASE_DRAIN_RATES)) {
    const resourceKey = key as ResourceKey;
    const effectiveRate = this.effectiveDrainRate(resourceKey);
    const drain = effectiveRate * speedMultiplier;
    this.resources[resourceKey] = clampResource(
      this.resources[resourceKey] - drain
    );
  }

  // Apply recovery to recovering resources
  for (const [key, baseRate] of Object.entries(BASE_RECOVERY_RATES)) {
    const resourceKey = key as ResourceKey;
    const effectiveRate = this.effectiveRecoveryRate(resourceKey);
    const recovery = effectiveRate * speedMultiplier;

    // Stress is inverse: recovery means it goes DOWN
    if (resourceKey === 'stress') {
      this.resources[resourceKey] = clampResource(
        this.resources[resourceKey] - recovery
      );
    } else {
      this.resources[resourceKey] = clampResource(
        this.resources[resourceKey] + recovery
      );
    }
  }
}
```

Update SimulationStore.tick() to call character.applyTickUpdate:
```typescript
tick(): void {
  this.tickCount += 1;
  this.root.characterStore.character?.applyTickUpdate(this.speed);
}
```

Also add computed boundary state flags to Character:
```typescript
get isExhausted(): boolean {
  return this.resources.energy <= 10;
}

get isOverstressed(): boolean {
  return this.resources.stress >= 90;
}

get isSociallyDrained(): boolean {
  return this.resources.socialBattery <= 10;
}
```
  </action>
  <verify>`npm run build` passes, `npm run lint` passes</verify>
  <done>applyTickUpdate method exists and is called by SimulationStore.tick()</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- `npm run lint` passes
- Character.activeModifiers returns array of ResourceModifier
- Character.applyTickUpdate(speed) modifies resources
- SimulationStore.tick() calls character.applyTickUpdate()
- Boundary flags (isExhausted, isOverstressed, isSociallyDrained) work
</verification>

<success_criteria>
1. All 5 Big Five traits affect at least one resource (CONTEXT.md requirement)
2. Modifiers are subtle (10-20% range per CONTEXT.md)
3. Resources drain/recover each tick based on personality
4. Boundary states computed for exhaustion/stress/social drain
5. Stress correctly inverted (high = bad, recovery reduces it)
</success_criteria>

<output>
After completion, create `.planning/phases/02-character-core/02-03-SUMMARY.md`
</output>
