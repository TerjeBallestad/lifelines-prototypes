# Phase 9.1: Activity Difficulty - Research

**Researched:** 2026-01-23
**Domain:** Difficulty calculation with weighted skill requirements, diminishing returns, and MobX computed values
**Confidence:** HIGH

## Summary

Activity difficulty is a multi-factor calculation combining base difficulty, skill requirements (weighted by relevance), and activity mastery. The existing codebase already has the foundation in place: MobX computed values pattern (used in Phase 9), activity mastery system (Activity.ts), skill levels (Skill.ts with 0-5 scale), and native Popover API tooltips (ActionResourcesSection.tsx).

The research identifies three critical technical components: (1) MobX computed getters for reactive difficulty calculation, (2) diminishing returns formulas to prevent min/maxing exploitation, and (3) weighted multi-skill contribution where primary skills matter more than secondary. The 5-star display with color gradient is straightforward CSS using DaisyUI's existing utilities.

Key architectural insight: Difficulty calculation belongs on the Activity entity as a computed getter that takes Character context as a parameter (not stored on Character), since the same activity can have different difficulties for different characters. This maintains entity separation while enabling per-patient personalization.

**Primary recommendation:** Use MobX computed getters on Activity entity with square root diminishing returns formula (proven game design pattern) for both skill and mastery contributions, weighted by configurable skill relevance.

## Standard Stack

The established libraries/tools for this domain:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| MobX | 6.x | Computed values for reactive difficulty | Already used in Phase 9 for action resources, proven pattern |
| TypeScript | 5.x | Type-safe skill requirements structure | Strong typing prevents skill mapping errors |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| DaisyUI | 4.x | Progress/badge classes for stars | Color gradients via progress-success/warning/error |
| Native Popover API | Browser | Tooltip breakdowns | Already pattern from Phase 9 (ActionResourcesSection.tsx) |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Computed on Activity | Computed on Character | Activity approach maintains entity separation, supports multiple patients |
| Square root formula | Logarithmic | Square root provides better player feedback (visible improvements longer) |
| Native Popover | Library (Tippy.js) | Native API is lighter, already standardized in Phase 9 |

**Installation:**
```bash
# No new dependencies - all libraries already in project
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── entities/
│   ├── Activity.ts         # Add difficulty computed getters here
│   ├── Skill.ts            # Existing 0-5 level system
│   └── Character.ts        # Reference skills on character
├── types/
│   └── difficulty.ts       # NEW: Difficulty types and skill requirements
├── components/
│   └── ActivityCard.tsx    # Display stars with tooltip
└── config/
    └── balance.ts          # Add difficulty config section
```

### Pattern 1: Difficulty as Computed Getter on Activity
**What:** Activity entity has `getEffectiveDifficulty(character: Character): number` computed method that calculates personalized difficulty using character's skills and activity mastery.
**When to use:** For any activity system where same activity has different difficulty for different characters.
**Example:**
```typescript
// Source: Existing MobX pattern from Character.ts actionResources
class Activity {
  readonly baseDifficulty: number = 3; // 1-5 base stars
  readonly skillRequirements: SkillRequirement[] = [
    { skillId: 'phone-call', weight: 1.0 },    // Primary skill
    { skillId: 'small-talk', weight: 0.5 },    // Secondary skill
  ];

  masteryLevel = 1; // 1-10, existing property

  // Computed getter takes character context as parameter
  getEffectiveDifficulty(character: Character): number {
    const skillReduction = this.calculateSkillReduction(character);
    const masteryReduction = this.calculateMasteryReduction();

    // Additive model per CONTEXT.md decision
    const effective = this.baseDifficulty - skillReduction - masteryReduction;

    // Clamp to 1-5 range (minimum 1 star even when overtrained)
    return Math.max(1, Math.min(5, effective));
  }
}
```

### Pattern 2: Weighted Skill Contribution with Diminishing Returns
**What:** Multi-skill activities use weighted average where primary skills (weight 1.0) reduce more difficulty than secondary skills (weight 0.3-0.5). Each skill's contribution has diminishing returns via square root formula.
**When to use:** When activities require multiple skills but some are more relevant than others.
**Example:**
```typescript
// Source: Game design research on diminishing returns formulas
calculateSkillReduction(character: Character): number {
  let totalReduction = 0;
  let totalWeight = 0;

  for (const req of this.skillRequirements) {
    const skill = character.getSkill(req.skillId);
    if (!skill) continue;

    // Square root diminishing returns: sqrt(level/maxLevel) * maxReduction
    // Level 0: 0%, Level 1: 0.45 stars, Level 3: 0.77 stars, Level 5: 1.0 stars
    const diminishedValue = Math.sqrt(skill.level / 5);
    const reduction = diminishedValue * req.maxReduction * req.weight;

    totalReduction += reduction;
    totalWeight += req.weight;
  }

  // Normalize by total weight for weighted average
  return totalWeight > 0 ? totalReduction / totalWeight : 0;
}
```

### Pattern 3: Activity Mastery Separate from Skills
**What:** Activity mastery (1-10) represents practice on THIS activity, while skills (0-5) are general transferable abilities. Both reduce difficulty independently (additive model).
**When to use:** When you want distinct progression axes - specific practice vs general competence.
**Example:**
```typescript
// Source: Existing Activity.ts masteryBonus pattern
calculateMasteryReduction(): number {
  // Mastery 1: 0 reduction, Mastery 10: 1.0 stars reduction
  // Square root curve: sqrt((level-1)/(10-1))
  const normalizedLevel = (this.masteryLevel - 1) / 9;
  return Math.sqrt(normalizedLevel) * 1.0; // Max 1 star reduction from mastery
}
```

### Pattern 4: Native Popover API for Cost Breakdown
**What:** Use native browser Popover API (popover="manual") with manual show/hide on hover, positioned relative to trigger element.
**When to use:** Already standardized in Phase 9 (ActionResourcesSection.tsx), consistent pattern.
**Example:**
```typescript
// Source: src/components/ActionResourcesSection.tsx lines 39-56
const showPopover = () => {
  const popover = popoverRef.current;
  const trigger = triggerRef.current;
  if (!popover || !trigger) return;

  // Position popover to the right of trigger
  const rect = trigger.getBoundingClientRect();
  popover.style.top = `${rect.top + rect.height / 2}px`;
  popover.style.left = `${rect.right + 8}px`;
  popover.style.transform = 'translateY(-50%)';

  popover.showPopover();
};

// JSX:
<div ref={popoverRef} id={popoverId} popover="manual"
     className="m-0 rounded bg-neutral px-3 py-2 text-sm">
  {/* Breakdown content */}
</div>
```

### Pattern 5: Color Gradient for Star Rating
**What:** Map 1-5 stars to DaisyUI progress color classes: progress-success (green), progress-warning (yellow), progress-error (red).
**When to use:** Visual difficulty indication with semantic colors.
**Example:**
```typescript
// Map difficulty stars to color class
function getDifficultyColor(stars: number): string {
  if (stars <= 2) return 'text-success'; // 1-2 stars = green
  if (stars <= 3.5) return 'text-warning'; // 3 stars = yellow
  return 'text-error'; // 4-5 stars = red
}

// Display stars with color
<div className={getDifficultyColor(effectiveDifficulty)}>
  {'★'.repeat(Math.floor(effectiveDifficulty))}
  {'☆'.repeat(5 - Math.floor(effectiveDifficulty))}
</div>
```

### Anti-Patterns to Avoid
- **Storing difficulty on Character:** Difficulty is activity + character interaction, belongs on Activity as computed method with Character parameter
- **Linear skill reduction:** Creates "breakpoint" feel where each skill level has identical value; use square root for smoothing
- **1:1 skill-activity mapping:** Activities should require MULTIPLE skills with weights, not single "cooking skill for cooking activity"
- **Separate mastery and skill caps:** If both can reach 100% reduction, difficulty becomes meaningless; cap combined effect at ~80% reduction (diminishing returns to 1★ minimum)

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Tooltip positioning | Custom calc with viewport detection | Native Popover API with manual positioning | Already pattern in codebase, handles edge cases |
| Diminishing returns curve | Custom exponential formula | Square root formula `sqrt(x/max)` | Game design proven, predictable player feedback |
| Skill requirement validation | Runtime checks in activity execution | TypeScript type checking with SkillRequirement interface | Catches errors at compile time, self-documenting |
| Color interpolation for gradients | Manual RGB lerp | DaisyUI semantic color classes (success/warning/error) | Maintains theme consistency, accessibility built-in |
| Difficulty state updates | Manual setState calls | MobX computed values with autorun | Automatic dependency tracking, prevents stale data |

**Key insight:** Game design patterns for difficulty scaling are well-established and mathematically validated. Square root diminishing returns prevents exploitation while maintaining player motivation (every level still helps, but optimization requires broad skill development).

## Common Pitfalls

### Pitfall 1: Difficulty Calculation in Wrong Location
**What goes wrong:** Storing computed difficulty on Character entity leads to data duplication and staleness issues. Character needs difficulty for Activity A, B, C... storing all computed values is O(n) space and requires cache invalidation.
**Why it happens:** Natural instinct is "Character has difficulty" but difficulty is actually a relationship, not a property.
**How to avoid:** Difficulty calculation belongs on Activity as a method that accepts Character as parameter. Activity.getEffectiveDifficulty(character) computes on-demand with MobX memoization.
**Warning signs:** Finding yourself creating "difficultyCache" or "recomputeAllDifficulties" methods on Character.

### Pitfall 2: Linear Skill Contribution
**What goes wrong:** Linear reduction (1 skill level = 0.2 stars) creates exploitable min/maxing where single skill investment is optimal strategy. Also creates "breakpoints" where leveling skill 2→3 has identical value to 4→5.
**Why it happens:** Linear math is simpler to implement and reason about.
**How to avoid:** Use square root diminishing returns: `reduction = sqrt(level/maxLevel) * maxReduction`. First level gives biggest boost (~45% of max), later levels give smaller increments.
**Warning signs:** Playtesting reveals players focus entirely on one skill, ignore others. Difficulty feels "chunky" rather than smooth.

### Pitfall 3: Mastery Eclipsing Skills
**What goes wrong:** If mastery alone can reduce difficulty to 1★, skills become irrelevant. Player optimal strategy: grind easiest activities to mastery 10, ignore skill system entirely.
**Why it happens:** Independent reduction systems without coordination on combined caps.
**How to avoid:** Cap mastery contribution at ~1 star reduction, skills at ~1.5 stars reduction. With 3★ base difficulty, both systems required to reach 1★ minimum (3 - 1.5 - 1.0 = 0.5, clamped to 1★).
**Warning signs:** Players report "skills don't matter once I have mastery" or "I just spam the same activity forever."

### Pitfall 4: Forgetting Weighted Normalization
**What goes wrong:** Weighted skill requirements calculated as simple sum creates weird scaling where activities with MORE requirements become EASIER (sum of reductions is larger).
**Why it happens:** Forgetting to divide by total weight after computing weighted sum.
**How to avoid:** Always normalize weighted contribution: `totalReduction / totalWeight`. This ensures weighted average maintains consistent scale regardless of number of requirements.
**Warning signs:** Activity with 3 skill requirements has lower effective difficulty than activity with 1 requirement, even when player skills are equal.

### Pitfall 5: Skill Requirements as Soft Hints
**What goes wrong:** Treating skill requirements as "these help but not required" makes underqualified attempts feel arbitrary. Player attempts 5★ activity with 0 skills, sometimes succeeds, system feels random.
**Why it happens:** Unclear distinction between requirements (gates) and contributions (modifiers).
**How to avoid:** Requirements are HARD gates for variant unlocking (need skill level X to see this variant), effective difficulty is SOFT modifier once unlocked. Use `startRequirements` field for hard gates.
**Warning signs:** Players report "I don't understand when I can do activities" or "difficulty rating seems meaningless."

## Code Examples

Verified patterns from official sources:

### Skill Requirement Type Definition
```typescript
// Source: TypeScript best practices for game data structures
export interface SkillRequirement {
  skillId: string;           // Reference to Skill.id
  weight: number;            // 1.0 = primary, 0.3-0.5 = secondary
  maxReduction: number;      // Max stars this skill can reduce (typically 0.5-1.0)
  minLevelForVariant?: number; // Optional: unlock gate for activity variant
}

export interface ActivityDifficultyData {
  baseDifficulty: number;          // 1-5 stars before modifiers
  skillRequirements: SkillRequirement[];
  underqualifiedPenalty?: {        // Optional: penalties for insufficient skills
    costMultiplier: number;        // 1.5 = 50% higher resource costs
    rewardMultiplier: number;      // 0.5 = 50% reduced rewards
    failureChance: number;         // 0.2 = 20% chance of failure
  };
}
```

### Difficulty Calculation with Breakdown
```typescript
// Source: MobX computed pattern from Character.ts
class Activity {
  getEffectiveDifficulty(character: Character): number {
    const skillReduction = this.calculateSkillReduction(character);
    const masteryReduction = this.calculateMasteryReduction();

    const effective = this.baseDifficulty - skillReduction - masteryReduction;
    return Math.max(1, Math.min(5, effective));
  }

  // For tooltip display
  getDifficultyBreakdown(character: Character): DifficultyBreakdown {
    const skillReduction = this.calculateSkillReduction(character);
    const masteryReduction = this.calculateMasteryReduction();
    const skillContributions = this.getSkillContributions(character);

    return {
      base: this.baseDifficulty,
      effective: this.getEffectiveDifficulty(character),
      skillReduction: -skillReduction,
      masteryReduction: -masteryReduction,
      skillDetails: skillContributions, // Per-skill breakdown
    };
  }
}
```

### Square Root Diminishing Returns Implementation
```typescript
// Source: Game design research on diminishing returns formulas
function applyDiminishingReturns(
  currentLevel: number,
  maxLevel: number,
  maxBenefit: number
): number {
  if (currentLevel <= 0) return 0;
  if (currentLevel >= maxLevel) return maxBenefit;

  // Square root curve: sqrt(x/max) * benefit
  // Provides ~45% of max benefit at level 1, ~71% at level 2, 100% at max
  const normalized = currentLevel / maxLevel;
  return Math.sqrt(normalized) * maxBenefit;
}

// Example progression for skill 0-5 with 1.0 star max reduction:
// Level 0: 0.00 stars
// Level 1: 0.45 stars
// Level 2: 0.63 stars
// Level 3: 0.77 stars
// Level 4: 0.89 stars
// Level 5: 1.00 stars
```

### Resource Cost Scaling from Difficulty
```typescript
// Source: Existing Activity.resourceEffects pattern
function calculateResourceCost(
  baseEffect: number,
  effectiveDifficulty: number,
  personalityAlignment: number
): number {
  // Difficulty affects base cost (linear scaling per CONTEXT.md)
  // 1★ = 100% cost, 3★ = 100% cost, 5★ = 100% cost - difficulty is SEPARATE from personality
  // Wait no - difficulty DOES affect cost per requirements

  // Difficulty scaling: higher difficulty = higher cost
  // 1★ = 0.6x cost, 3★ = 1.0x cost, 5★ = 1.4x cost
  const difficultyMultiplier = 0.6 + (effectiveDifficulty - 1) * 0.2;

  // Personality alignment affects cost (Phase 9 decision: secondary effect)
  // Well-aligned = -20% cost, poorly-aligned = +20% cost
  const alignmentMultiplier = 1.0 - (personalityAlignment * 0.2);

  return baseEffect * difficultyMultiplier * alignmentMultiplier;
}
```

### Star Display Component
```typescript
// Source: DaisyUI progress colors and CSS patterns
function DifficultyStars({
  difficulty,
  breakdown
}: {
  difficulty: number;
  breakdown: DifficultyBreakdown;
}) {
  const popoverId = useId();
  const filled = Math.floor(difficulty);
  const empty = 5 - filled;

  // Color based on difficulty
  const colorClass = difficulty <= 2
    ? 'text-success'
    : difficulty <= 3.5
      ? 'text-warning'
      : 'text-error';

  return (
    <div>
      <span
        className={`cursor-help ${colorClass}`}
        onMouseEnter={showPopover}
        onMouseLeave={hidePopover}
      >
        {'★'.repeat(filled)}{'☆'.repeat(empty)}
      </span>

      <div ref={popoverRef} id={popoverId} popover="manual"
           className="m-0 rounded bg-neutral px-3 py-2 text-sm">
        <div className="font-semibold">Difficulty: {difficulty.toFixed(1)}★</div>
        <div className="mt-2 space-y-1 text-xs">
          <div>Base: {breakdown.base}★</div>
          {breakdown.skillReduction !== 0 && (
            <div>Skills: {breakdown.skillReduction.toFixed(1)}★</div>
          )}
          {breakdown.masteryReduction !== 0 && (
            <div>Mastery: {breakdown.masteryReduction.toFixed(1)}★</div>
          )}
        </div>

        {/* Per-skill breakdown */}
        {breakdown.skillDetails.length > 0 && (
          <div className="mt-2 border-t border-neutral-content/20 pt-2">
            <div className="font-semibold text-xs mb-1">Skill Contributions:</div>
            {breakdown.skillDetails.map(detail => (
              <div key={detail.skillId} className="text-xs">
                {detail.skillName} Lv.{detail.level}: {detail.reduction.toFixed(2)}★
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single "difficulty" stat per activity | Multi-factor calculation (base + skills + mastery) | 2020s game design | More nuanced progression, player agency in specialization |
| Linear scaling (1 level = 1 benefit) | Diminishing returns (square root curves) | 2010s post-WoW era | Prevents min/maxing, encourages broad skill development |
| Global difficulty slider | Per-activity personalized difficulty | Modern accessibility | Same game accommodates different player skill levels naturally |
| Tooltip libraries (Tippy.js, Popper) | Native Popover API | 2024+ browser support | Zero dependencies, better performance, standards-based |

**Deprecated/outdated:**
- Linear skill contribution: Replaced by diminishing returns formulas for better game balance
- Stored computed difficulty: Modern reactive frameworks (MobX, Solid) make on-demand computation with memoization more efficient
- Single-skill requirements: Modern activity systems use weighted multi-skill requirements for richer progression

## Open Questions

Things that couldn't be fully resolved:

1. **Cost scaling from difficulty vs personality alignment**
   - What we know: CONTEXT.md says "personality alignment affects resource gains (primary) and costs (secondary), not difficulty stars"
   - What's unclear: Exact formula for how effective difficulty maps to resource cost multiplier
   - Recommendation: Start with linear scaling (1★ = 0.6x cost, 3★ = 1.0x cost, 5★ = 1.4x cost), personality alignment as separate multiplier (-20% to +20%)

2. **Underqualified attempt mechanics**
   - What we know: CONTEXT.md specifies "higher costs, reduced rewards, AND risk of failure"
   - What's unclear: How to define "underqualified" threshold (skills below 50% of requirement? Any skill at 0?)
   - Recommendation: Define minimum total skill level (sum of weighted skill levels / sum of weights >= 0.3 = qualified, < 0.3 = underqualified with penalties)

3. **Activity variant unlock criteria**
   - What we know: "Harder variants unlock via skill levels" and skill requirements can have minLevelForVariant
   - What's unclear: Should unlock require ALL skills at minimum level, or weighted threshold, or specific primary skill?
   - Recommendation: Primary skill (highest weight) must meet minimum level for variant to appear in activity list

4. **Star display precision**
   - What we know: 5-star rating system, effective difficulty is decimal (2.7★)
   - What's unclear: Display as decimal (2.7★), round to nearest half (2.5★), or full stars only (3★)?
   - Recommendation: Display full stars only in card (visual simplicity), show exact decimal in tooltip breakdown (precise information)

## Sources

### Primary (HIGH confidence)
- [MobX Computeds Documentation](https://mobx.js.org/computeds.html) - Official documentation for computed values best practices
- Existing codebase patterns:
  - `src/entities/Character.ts` lines 548-720 - Action resources computed getters pattern
  - `src/entities/Activity.ts` lines 49-92 - Mastery bonus computed properties
  - `src/components/ActionResourcesSection.tsx` lines 34-89 - Native Popover API implementation
  - `src/config/balance.ts` - Balance configuration architecture

### Secondary (MEDIUM confidence)
- [Diminishing Returns in Game Design: Roots and Negative Exponents](https://blog.nerdbucket.com/diminishing-returns-in-game-design-roots-and-negative-exponents/article) - Square root formula for game balance
- [Exploring Dynamic Difficulty Adjustment in Videogames](https://www.mdpi.com/2813-2084/3/2/12) - Weighted average for multiple skill parameters
- [Player Skill, Character Skill, and Skill Progression Systems](https://www.gamedeveloper.com/design/player-skill-character-skill-and-skill-progression-systems) - Mastery vs general skill distinction
- [Figuring out Failure in Game Design](https://www.gamedeveloper.com/design/figuring-out-failure-in-game-design) - Underqualified attempt mechanics

### Tertiary (LOW confidence)
- [Pure CSS Star Rating System With Color Change](https://developerchirag.medium.com/pure-css-star-rating-system-with-color-change-5d05f536e788) - Visual star rating implementation ideas (not critical)

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All libraries already in project, proven patterns exist in codebase
- Architecture: HIGH - MobX computed pattern verified in Character.ts, entity separation clear
- Difficulty formulas: HIGH - Square root diminishing returns is established game design practice with mathematical validation
- Skill weighting: MEDIUM - Weighted average approach supported by research, but exact balance values need playtesting
- Cost scaling: MEDIUM - Linear scaling is reasonable starting point per CONTEXT.md, personality separation clear
- UI patterns: HIGH - Native Popover API already implemented in Phase 9, DaisyUI colors standard

**Research date:** 2026-01-23
**Valid until:** 2026-02-23 (30 days - stable domain, core patterns unlikely to change)
