---
phase: 03-skills-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/stores/SkillStore.ts
autonomous: true

must_haves:
  truths:
    - "SkillStore manages skills in an ObservableMap"
    - "Domain XP is tracked per domain and can be spent"
    - "DAG validation prevents circular dependencies"
    - "Skill states (locked/unlockable/unlocked/mastered) are computed from prerequisites"
  artifacts:
    - path: "src/stores/SkillStore.ts"
      provides: "SkillStore with DAG logic, domain XP, unlock actions"
      exports: ["SkillStore"]
      min_lines: 100
  key_links:
    - from: "src/stores/SkillStore.ts"
      to: "src/entities/Skill.ts"
      via: "imports Skill class"
      pattern: "import.*Skill.*from.*entities/Skill"
    - from: "src/stores/SkillStore.ts"
      to: "src/entities/types.ts"
      via: "imports SkillDomain, SkillData"
      pattern: "import.*SkillDomain.*from.*types"
---

<objective>
Create SkillStore with DAG dependency logic, domain XP management, and computed skill states.

Purpose: Central store for skill system with validation, state derivation, and unlock mechanics.
Output: SkillStore.ts with ObservableMap-based skill collection and domain XP tracking
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-skills-system/03-CONTEXT.md
@.planning/phases/03-skills-system/03-RESEARCH.md

# Existing patterns to follow
@src/stores/CharacterStore.ts
@src/stores/RootStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SkillStore with skill collection and domain XP</name>
  <files>src/stores/SkillStore.ts</files>
  <action>
Create src/stores/SkillStore.ts following CharacterStore pattern:

1. Imports:
   - { makeAutoObservable, observable } from 'mobx'
   - { Skill } from '../entities/Skill'
   - { SkillDomain, SkillData, SkillState, PrerequisiteStatus } from '../entities/types'
   - type { RootStore } from './RootStore'

2. Define DOMAINS constant array: ['social', 'organisational', 'analytical', 'physical', 'creative']

3. SkillStore class:
   Properties:
   - skills = observable.map<string, Skill>() (skill ID -> Skill)
   - domainXP = observable.map<SkillDomain, number>() (domain -> XP amount)
   - private readonly root: RootStore

   Constructor(root: RootStore):
   - Assign root
   - Call makeAutoObservable(this)
   - Initialize domainXP for all 5 domains to 0

   Computed getter - skillsArray: Skill[]
   - Returns Array.from(this.skills.values())

   Method - skillsByDomain(domain: SkillDomain): Skill[]
   - Returns skills filtered by domain

   Method - getSkill(id: string): Skill | undefined
   - Returns this.skills.get(id)
  </action>
  <verify>`npx tsc --noEmit` compiles (will have errors until types exist from Plan 01, that's expected)</verify>
  <done>SkillStore exists with skills ObservableMap, domainXP ObservableMap, basic accessors</done>
</task>

<task type="auto">
  <name>Task 2: Add skill state computation and prerequisite checking</name>
  <files>src/stores/SkillStore.ts</files>
  <action>
Add to SkillStore class:

1. Method - isUnlockable(skillId: string): boolean
   - Get skill by ID, return false if not found
   - Return false if skill.level > 0 (already unlocked)
   - Return true if ALL prerequisites have level >= 1
   - Use: skill.prerequisites.every(prereqId => this.skills.get(prereqId)?.level >= 1)

2. Method - getSkillState(skillId: string): SkillState
   - Get skill, return 'locked' if not found
   - If skill.level >= 5: return 'mastered'
   - If skill.level >= 1: return 'unlocked'
   - If this.isUnlockable(skillId): return 'unlockable'
   - Otherwise: return 'locked'

3. Method - getPrerequisiteProgress(skillId: string): PrerequisiteStatus[]
   - Get skill, return [] if not found
   - Map over skill.prerequisites:
     - Look up each prerequisite skill
     - Return { skillId: prereqId, name: prereq?.name || 'Unknown', required: 1, current: prereq?.level || 0, met: (prereq?.level || 0) >= 1 }

4. Method - canAffordUnlock(skillId: string): boolean
   - Get skill, return false if not found
   - Get domain XP for skill.domain
   - Return domainXP >= skill.nextLevelCost
  </action>
  <verify>`npx tsc --noEmit` compiles</verify>
  <done>Skill state computed from prerequisites, prerequisite progress trackable, affordability checkable</done>
</task>

<task type="auto">
  <name>Task 3: Add DAG validation and unlock/seed actions</name>
  <files>src/stores/SkillStore.ts</files>
  <action>
Add to SkillStore class:

1. Action - seedSkills(skillDataList: SkillData[]): void
   - For each SkillData in list:
     - Create new Skill(data)
     - Add to this.skills.set(data.id, skill)
   - After all added, call this.validateDAG()

2. Private method - validateDAG(): boolean
   - Use Kahn's algorithm to check for cycles:
     - Build inDegree map (count how many skills depend on each skill)
     - Start with skills that have no prerequisites (inDegree 0)
     - Process queue, decrementing inDegree for dependents
     - If visited count < total skills, cycle exists
   - If cycle detected, console.warn with message
   - Return true if acyclic, false if cyclic

3. Action - unlockSkillLevel(skillId: string): boolean
   - Get skill, return false if not found
   - Check if unlockable (prerequisites met for level 0->1) or already unlocked (level 1-4)
   - Check canAffordUnlock
   - If all checks pass:
     - Deduct skill.nextLevelCost from domainXP.get(skill.domain)
     - Call skill.levelUp()
     - Return true
   - Otherwise return false

4. Action - addDomainXP(domain: SkillDomain, amount: number): void
   - Add amount to current domainXP for that domain
   - (This will be called by activities in Phase 4)

5. Computed getter - rootStore: RootStore
   - Return this.root
  </action>
  <verify>
1. `npx tsc --noEmit` compiles
2. The store compiles standalone (RootStore type import is forward reference)
  </verify>
  <done>DAG validation prevents cycles, unlockSkillLevel spends XP and levels up, addDomainXP allows XP addition</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. SkillStore has: skills ObservableMap, domainXP ObservableMap
3. State derivation: getSkillState returns correct state based on level and prerequisites
4. Unlock logic: unlockSkillLevel validates prerequisites, checks XP, deducts XP, calls levelUp
5. DAG validation: validateDAG uses Kahn's algorithm to detect cycles
</verification>

<success_criteria>
- SkillStore manages skills in ObservableMap
- Domain XP tracked per domain (5 domains)
- isUnlockable checks all prerequisites
- getSkillState returns locked/unlockable/unlocked/mastered
- getPrerequisiteProgress shows progress toward each prerequisite (SKIL-05)
- unlockSkillLevel validates and deducts XP
- validateDAG detects circular dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/03-skills-system/03-02-SUMMARY.md`
</output>
