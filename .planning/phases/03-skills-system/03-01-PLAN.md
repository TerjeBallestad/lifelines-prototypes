---
phase: 03-skills-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/entities/types.ts
  - src/entities/Skill.ts
autonomous: true

must_haves:
  truths:
    - "Skill type definitions exist for domain, state, and data shapes"
    - "Skill entity class is observable with MobX"
    - "Skill has level (0-5) and can compute XP cost for next level"
  artifacts:
    - path: "src/entities/types.ts"
      provides: "SkillDomain, SkillState, SkillData, PrerequisiteStatus types"
      contains: "SkillDomain"
    - path: "src/entities/Skill.ts"
      provides: "Skill entity class with observable properties"
      exports: ["Skill"]
      min_lines: 40
  key_links:
    - from: "src/entities/Skill.ts"
      to: "src/entities/types.ts"
      via: "imports SkillData, SkillDomain"
      pattern: "import.*SkillData.*from.*types"
---

<objective>
Create the Skill entity class with observable state, level management, and XP cost calculations.

Purpose: Establishes the foundational skill data model following the Character entity pattern from Phase 1-2.
Output: Skill.ts entity class and supporting type definitions in types.ts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-skills-system/03-CONTEXT.md
@.planning/phases/03-skills-system/03-RESEARCH.md

# Existing patterns to follow
@src/entities/Character.ts
@src/entities/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add skill type definitions to types.ts</name>
  <files>src/entities/types.ts</files>
  <action>
Add the following type definitions at the end of types.ts:

1. SkillDomain union type: 'social' | 'organisational' | 'analytical' | 'physical' | 'creative'
2. SkillState union type: 'locked' | 'unlockable' | 'unlocked' | 'mastered'
3. SkillData interface for constructing skills:
   - id: string
   - name: string
   - description: string
   - domain: SkillDomain
   - prerequisites: string[] (skill IDs that must be level >= 1)
4. PrerequisiteStatus interface for "why locked" display:
   - skillId: string
   - name: string
   - required: number (always 1 for now)
   - current: number (current level)
   - met: boolean

Follow the existing types.ts conventions (no JSDoc, inline comments only where needed).
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit`</verify>
  <done>SkillDomain, SkillState, SkillData, and PrerequisiteStatus types are exported from types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create Skill entity class</name>
  <files>src/entities/Skill.ts</files>
  <action>
Create src/entities/Skill.ts following the Character.ts pattern:

1. Import makeAutoObservable from 'mobx'
2. Import SkillData, SkillDomain from './types'

3. Create Skill class with:
   Properties (all observable via makeAutoObservable):
   - id: string (readonly)
   - name: string (readonly)
   - description: string (readonly)
   - domain: SkillDomain (readonly)
   - prerequisites: string[] (readonly)
   - level: number (mutable, 0-5, starts at 0)

   Constructor:
   - Takes SkillData parameter
   - Assigns all properties from data
   - Sets level = 0
   - Calls makeAutoObservable(this)

   Computed getter - nextLevelCost: number
   - Returns Infinity if level >= 5
   - Uses escalating cost curve: level 1 = 50, level 2 = 75, level 3 = 100, level 4 = 125, level 5 = 150
   - Formula: 50 + (nextLevel - 1) * 25

   Action - levelUp(): void
   - Increments level if level < 5

   Computed getter - isMastered: boolean
   - Returns level >= 5

Export the Skill class as named export.
  </action>
  <verify>
1. `npx tsc --noEmit` compiles without errors
2. Create a quick test in node REPL or temp file to verify:
   - new Skill({ id: 'test', name: 'Test', description: '', domain: 'social', prerequisites: [] })
   - Verify .level is 0, .nextLevelCost is 50
  </verify>
  <done>Skill entity class exists with observable properties, nextLevelCost computed, and levelUp action</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. types.ts exports: SkillDomain, SkillState, SkillData, PrerequisiteStatus
3. Skill.ts exports: Skill class
4. Skill class pattern matches Character.ts (makeAutoObservable, readonly data props, mutable level)
</verification>

<success_criteria>
- Skill type definitions exist and compile
- Skill entity class is observable (makeAutoObservable)
- Skill.nextLevelCost returns escalating costs: 50, 75, 100, 125, 150
- Skill.levelUp() increments level (max 5)
- Follows existing Character.ts conventions
</success_criteria>

<output>
After completion, create `.planning/phases/03-skills-system/03-01-SUMMARY.md`
</output>
