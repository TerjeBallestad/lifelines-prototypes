# Phase 10.1: Remove v1.0 Resource System - Research

**Researched:** 2026-01-25
**Domain:** TypeScript/MobX code cleanup and deprecation removal
**Confidence:** HIGH

## Summary

This research investigates how to safely remove the legacy v1.0 flat resource system (energy, mood, overskudd as flat values) now that Phase 10 has verified the v1.1 needs-based system is working correctly. The primary technical challenge is removing code paths, types, and UI elements that are no longer needed while ensuring no runtime errors occur when starting a fresh game.

The v1.0 system includes: flat resource properties on Character (Resources type), resourceEffects on activities, needsSystemEnabled toggle in RootStore, v1.0-specific UI components (ResourcePanel), and toggle UI controls. All of these are now obsolete since v1.1 (primary needs → derived wellbeing → action resources) has been verified as complete and working.

**Primary recommendation:** Use TypeScript's type system for compile-time safety, remove code systematically in dependency order (UI → store → types), and verify with manual testing that fresh game starts work correctly.

## Standard Stack

The codebase uses MobX 6 with TypeScript for state management. This cleanup task requires no new libraries.

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| MobX | 6.15.0 | Observable state management | Project's chosen state management solution |
| TypeScript | 5.9.3 | Type safety during refactoring | Catches property access errors at compile time |
| mobx-react-lite | 4.1.1 | React observer bindings | Integration between MobX and React components |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| None required | - | This is pure code removal | - |

**Installation:**
No new packages required for this phase.

## Architecture Patterns

### Recommended Removal Order

Code should be removed in reverse dependency order to minimize breakage:

```
1. UI Components (consumers)
   ├── SimulationControls.tsx (toggle UI)
   ├── CharacterPanel.tsx (v1.0/v1.1 branch)
   └── ResourcePanel.tsx (entire component)

2. Store Logic (business layer)
   ├── RootStore.ts (needsSystemEnabled, toggleNeedsSystem)
   ├── ActivityStore.ts (v1.0 resource checks)
   └── Character.ts (Resources properties, v1.0 methods)

3. Types (foundation)
   ├── types.ts (Resources type)
   └── Activity.ts (resourceEffects property)

4. Data Files
   └── activities.ts (resourceEffects from activity definitions)
```

### Pattern 1: Type-Driven Removal

**What:** Use TypeScript's compiler errors as a checklist for what needs updating.

**When to use:** When removing a type or property that's used in multiple places.

**Example:**
```typescript
// Before: Resources type exists in types.ts
export type Resources = {
  energy: number;
  mood: number;
  overskudd: number;
  // ... 9 total properties
};

// After: Remove Resources type completely
// TypeScript will report all usages as compile errors
// ❌ Error: Cannot find name 'Resources'

// Fix each error by:
// 1. Remove the property/import
// 2. Replace with v1.1 equivalent if needed
// 3. Delete dead code if no equivalent exists
```

### Pattern 2: Branch Elimination (Toggle Removal)

**What:** Remove conditional branches that check feature toggles, keeping only the "new" code path.

**When to use:** When removing a feature flag after the new implementation is verified.

**Example:**
```typescript
// Before: Branching on needsSystemEnabled toggle
const overskudd = this.root.needsSystemEnabled && character.actionResources
  ? character.actionResources.overskudd
  : character.resources.overskudd;

// After: Only v1.1 path remains
const overskudd = character.actionResources.overskudd;

// Before: Conditional in applyTickUpdate
if (needsEnabled && this.needs) {
  this.applyNeedsDecay(speedMultiplier);
} else {
  // v1.0 resource drain/recovery logic
}

// After: Only v1.1 path remains
// applyNeedsDecay always runs, no branch needed
this.applyNeedsDecay(speedMultiplier);
```

### Pattern 3: Guard Removal (Initialization Required)

**What:** Remove optional chaining and guards that allowed v1.0 mode to skip v1.1 initialization.

**When to use:** When v1.1 becomes mandatory and initialization always happens.

**Example:**
```typescript
// Before: Optional needs/actionResources
needs?: Needs;
actionResources?: ActionResources;

// Access with guards
if (!this.actionResources) return;
this.actionResources.overskudd = value;

// After: Required properties
needs: Needs;
actionResources: ActionResources;

// Access without guards
this.actionResources.overskudd = value;

// Constructor must initialize
constructor(data: CharacterData, root?: RootStore) {
  // ... existing setup
  this.needs = data.needs ?? defaultNeeds();
  this.actionResources = data.actionResources ?? defaultActionResources();
  // Chain initialization of derived stats
  this.initializeDerivedStats();
}
```

### Pattern 4: UI Component Removal

**What:** Remove entire components that only served the old system, update parent components to remove references.

**When to use:** When a component has no purpose in the new system.

**Example:**
```typescript
// Before: CharacterPanel branches between v1.0 and v1.1 UI
{root.needsSystemEnabled && character.needs ? (
  <NeedsPanel {...needsProps} />
) : (
  <ResourcePanel resources={character.resources} />
)}

// After: Only NeedsPanel remains
<NeedsPanel {...needsProps} />

// ResourcePanel.tsx can be deleted entirely
// Remove import statement as well
```

### Anti-Patterns to Avoid

- **Leaving dead code branches:** Don't comment out old code "just in case". Delete it. Git history preserves it.
- **Partial removal:** Don't remove half the v1.0 system and leave orphaned code. Complete the cleanup fully.
- **Skipping TypeScript errors:** Don't use `@ts-ignore` to suppress errors. Fix them properly.
- **Removing guards too early:** Keep optional chaining until you've confirmed initialization happens everywhere.

## Don't Hand-Roll

This is a straightforward code removal task. No need for custom solutions.

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Migration tool | Custom codemod/script | Manual removal with TypeScript errors as guide | Small codebase, TypeScript compiler is the best validation tool |
| Deprecation warnings | @deprecated decorators | Direct removal | Toggle already verified, no gradual deprecation needed |
| Backward compatibility | Serialization migration | Fresh start assumption | Phase 10 complete means v1.1 is the only system |

**Key insight:** TypeScript's type system is your migration tool. Let compiler errors guide the cleanup systematically.

## Common Pitfalls

### Pitfall 1: Removing Types Before Consumers

**What goes wrong:** Deleting the Resources type first causes 100+ compiler errors across the codebase, making it hard to track what actually needs fixing vs. what's already fixed.

**Why it happens:** Natural instinct to "start at the foundation" (types), but types are actually the last dependency in the chain.

**How to avoid:** Remove consumers first (UI components), then stores, then types. Work top-down in the dependency graph.

**Warning signs:** Massive wall of TypeScript errors after first deletion.

### Pitfall 2: Forgetting ActivityData resourceEffects

**What goes wrong:** Activity.ts class still has `resourceEffects` property even though it's never used in v1.1. Data files in `data/activities.ts` still define resourceEffects for each activity. These become dead weight.

**Why it happens:** Activities worked in v1.0 by applying resourceEffects directly. In v1.1, activities use `needEffects` instead and compute costs from difficulty. Easy to forget to clean up the old property.

**How to avoid:**
1. Remove resourceEffects from Activity class
2. Remove resourceEffects from ActivityData type
3. Remove resourceEffects definitions from all activity data in data/activities.ts
4. TypeScript will catch any remaining usages

**Warning signs:** Activities still have resourceEffects in their data definitions but nothing reads them.

### Pitfall 3: Character Boundary State Methods

**What goes wrong:** Character has `isExhausted`, `isOverstressed`, `isSociallyDrained` computed getters that check v1.0 resources. These might still be referenced in UI even though they don't make sense in v1.1.

**Why it happens:** These were boundary checks for v1.0 flat resources (energy <= 10, stress >= 90, socialBattery <= 10). In v1.1, the equivalents would be different (needs.energy <= 10, actionResources.socialBattery <= 10).

**How to avoid:**
1. Search for all usages of these getters
2. Either remove them entirely or reimplement using v1.1 properties
3. Update UI to show v1.1-appropriate warnings

**Warning signs:** Compiler doesn't error (getters still exist) but they return nonsense values (reading undefined v1.0 resources).

### Pitfall 4: Optional Chaining Masking Errors

**What goes wrong:** Code uses optional chaining (`character.needs?.energy`) which silently returns undefined if needs aren't initialized, hiding bugs where initialization is missing.

**Why it happens:** v1.0/v1.1 parallel system required optional chaining since needs were optional. After removal, needs should be mandatory.

**How to avoid:**
1. Change Character properties from optional to required
2. Ensure constructor always initializes needs/derivedStats/actionResources
3. Remove optional chaining operators (`?.`) throughout codebase
4. TypeScript will error if initialization is missing anywhere

**Warning signs:** Tests pass but values are undefined at runtime, no TypeScript errors.

### Pitfall 5: Forgetting Toggle UI in SimulationControls

**What goes wrong:** The "v1.1 Needs" toggle checkbox remains in SimulationControls.tsx even though needsSystemEnabled is removed from RootStore. UI element is useless clutter.

**Why it happens:** UI removal is easy to forget since removing the store property doesn't cause a TypeScript error in the UI (it just becomes a dead toggle).

**How to avoid:** Grep for `needsSystemEnabled` to find all UI references, not just store references.

**Warning signs:** Toggle appears in UI but does nothing, no errors in console.

## Code Examples

Verified patterns for this cleanup operation:

### Removing Toggle Branch in ActivityStore

```typescript
// Source: Codebase inspection (ActivityStore.ts canStartActivity method)

// Before: v1.0/v1.1 toggle logic
canStartActivity(activity: Activity): { canStart: boolean; reason?: string } {
  const character = this.root.characterStore.character;
  if (!character) {
    return { canStart: false, reason: 'No character available' };
  }

  // Toggle-based overskudd check
  const overskudd = this.root.needsSystemEnabled && character.actionResources
    ? character.actionResources.overskudd
    : character.resources.overskudd;

  if (overskudd < activity.getResourceCosts(character).overskudd) {
    return { canStart: false, reason: "Doesn't have the energy" };
  }

  // Similar toggle for energy check
  const energy = this.root.needsSystemEnabled && character.needs
    ? character.needs.energy
    : character.resources.energy;

  if (minEnergy !== undefined && energy < minEnergy) {
    return { canStart: false, reason: 'Too tired' };
  }

  return { canStart: true };
}

// After: Only v1.1 code path
canStartActivity(activity: Activity): { canStart: boolean; reason?: string } {
  const character = this.root.characterStore.character;
  if (!character) {
    return { canStart: false, reason: 'No character available' };
  }

  // Direct v1.1 access (no toggle)
  const overskudd = character.actionResources.overskudd;

  if (overskudd < activity.getResourceCosts(character).overskudd) {
    return { canStart: false, reason: "Doesn't have the energy" };
  }

  // Direct v1.1 access for energy need
  const energy = character.needs.energy;

  if (minEnergy !== undefined && energy < minEnergy) {
    return { canStart: false, reason: 'Too tired' };
  }

  return { canStart: true };
}
```

### Removing Character.applyTickUpdate v1.0 Branch

```typescript
// Source: Codebase inspection (Character.ts applyTickUpdate method)

// Before: Toggle switches between v1.0 drain and v1.1 needs decay
applyTickUpdate(speedMultiplier: number): void {
  const needsEnabled = this.root?.needsSystemEnabled ?? false;

  if (needsEnabled && this.needs) {
    // v1.1: Apply needs decay (asymptotic to prevent death spirals)
    this.applyNeedsDecay(speedMultiplier);
    this.applyDerivedStatsUpdate(speedMultiplier);
    this.applyActionResourcesUpdate(speedMultiplier);
  } else {
    // v1.0: Apply resource drain/recovery
    for (const key of Object.keys(BASE_DRAIN_RATES) as Array<ResourceKey>) {
      const effectiveRate = this.effectiveDrainRate(key);
      const drain = effectiveRate * speedMultiplier;
      this.resources[key] = clampResource(this.resources[key] - drain);
    }

    for (const key of Object.keys(BASE_RECOVERY_RATES) as Array<ResourceKey>) {
      const effectiveRate = this.effectiveRecoveryRate(key);
      const recovery = effectiveRate * speedMultiplier;
      if (key === 'stress') {
        this.resources[key] = clampResource(this.resources[key] - recovery);
      } else {
        this.resources[key] = clampResource(this.resources[key] + recovery);
      }
    }
  }
}

// After: Only v1.1 needs decay remains
applyTickUpdate(speedMultiplier: number): void {
  // Always apply v1.1 system (no toggle)
  this.applyNeedsDecay(speedMultiplier);
  this.applyDerivedStatsUpdate(speedMultiplier);
  this.applyActionResourcesUpdate(speedMultiplier);
}

// Note: BASE_DRAIN_RATES, BASE_RECOVERY_RATES, effectiveDrainRate,
// effectiveRecoveryRate, and activeModifiers can all be removed since
// they're only used in v1.0 resource drain logic
```

### Making Needs/ActionResources Required

```typescript
// Source: Codebase inspection (Character.ts type definitions)

// Before: Optional properties for toggle compatibility
export class Character {
  // ... existing properties
  needs?: Needs; // v1.1 Primary Needs (optional, initialized via initializeNeeds)
  derivedStats?: DerivedStats; // v1.1 Derived Wellbeing (optional)
  actionResources?: ActionResources; // v1.1 Action Resources (optional)

  constructor(data: CharacterData, root?: RootStore) {
    this.id = data.id;
    this.name = data.name;
    this.personality = data.personality;
    this.capacities = data.capacities;
    this.resources = data.resources; // v1.0 resources
    this.root = root;

    makeAutoObservable(this);
    // v1.1 initialization happens later via initializeNeeds()
  }
}

// After: Required properties, initialized in constructor
export class Character {
  // ... existing properties
  needs: Needs; // v1.1 Primary Needs (always present)
  derivedStats: DerivedStats; // v1.1 Derived Wellbeing (always present)
  actionResources: ActionResources; // v1.1 Action Resources (always present)
  // resources property removed entirely

  constructor(data: CharacterData, root?: RootStore) {
    this.id = data.id;
    this.name = data.name;
    this.personality = data.personality;
    this.capacities = data.capacities;
    this.root = root;

    // Initialize v1.1 properties immediately
    this.needs = data.needs ?? defaultNeeds();
    this.derivedStats = defaultDerivedStats();
    this.actionResources = defaultActionResources();

    makeAutoObservable(this);

    // Initialize smoothers and derived stats (needs balance config)
    if (root?.balanceConfig) {
      this.initializeDerivedStats();
    }
  }
}

// CharacterData type also updated
export type CharacterData = {
  id: string;
  name: string;
  personality: Personality;
  capacities: Capacities;
  needs?: Needs; // Optional in data for backward compat, but Character makes it required
  // resources removed entirely
};
```

### Removing Toggle UI from SimulationControls

```typescript
// Source: Codebase inspection (SimulationControls.tsx)

// Before: Toggle checkbox in controls
export const SimulationControls = observer(function SimulationControls() {
  const root = useRootStore();
  const simulationStore = useSimulationStore();
  const { isRunning, speed, tickCount, formattedTime } = simulationStore;

  return (
    <div className="bg-base-200 flex items-center gap-4 rounded-lg p-4">
      {/* Play/Pause, Speed slider, Time display... */}

      {/* v1.1 Needs System Toggle */}
      <label className="flex cursor-pointer items-center gap-2">
        <span className="text-sm">v1.1 Needs</span>
        <input
          type="checkbox"
          className="toggle toggle-primary"
          checked={root.needsSystemEnabled}
          onChange={() => root.toggleNeedsSystem()}
        />
      </label>
    </div>
  );
});

// After: Toggle UI removed entirely
export const SimulationControls = observer(function SimulationControls() {
  const simulationStore = useSimulationStore();
  const { isRunning, speed, tickCount, formattedTime } = simulationStore;

  return (
    <div className="bg-base-200 flex items-center gap-4 rounded-lg p-4">
      {/* Play/Pause, Speed slider, Time display... */}
      {/* Toggle removed - v1.1 is the only system */}
    </div>
  );
});
```

### Removing CharacterPanel v1.0 Branch

```typescript
// Source: Codebase inspection (CharacterPanel.tsx)

// Before: Conditional rendering based on toggle
<div className="border-base-300 border-b p-4">
  <h3 className="text-base-content/70 mb-2 text-sm font-semibold">
    {root.needsSystemEnabled ? 'Needs (v1.1)' : 'Resources'}
  </h3>
  {root.needsSystemEnabled && character.needs ? (
    <NeedsPanel
      needs={character.needs}
      needsConfig={root.balanceConfig.needsConfig}
      derivedStats={character.derivedStats}
      moodBreakdown={character.moodBreakdown}
      purposeEquilibrium={character.purposeEquilibrium}
      actionResources={character.actionResources}
      overskuddBreakdown={character.overskuddBreakdown}
      socialBatteryBreakdown={character.socialBatteryBreakdown}
      focusBreakdown={character.focusBreakdown}
      willpowerBreakdown={character.willpowerBreakdown}
      extraversion={character.personality.extraversion}
    />
  ) : (
    <ResourcePanel resources={character.resources} />
  )}
</div>

// After: Only NeedsPanel, no conditional
<div className="border-base-300 border-b p-4">
  <h3 className="text-base-content/70 mb-2 text-sm font-semibold">
    Needs
  </h3>
  <NeedsPanel
    needs={character.needs}
    needsConfig={root.balanceConfig.needsConfig}
    derivedStats={character.derivedStats}
    moodBreakdown={character.moodBreakdown}
    purposeEquilibrium={character.purposeEquilibrium}
    actionResources={character.actionResources}
    overskuddBreakdown={character.overskuddBreakdown}
    socialBatteryBreakdown={character.socialBatteryBreakdown}
    focusBreakdown={character.focusBreakdown}
    willpowerBreakdown={character.willpowerBreakdown}
    extraversion={character.personality.extraversion}
  />
</div>

// ResourcePanel.tsx can be deleted
// Remove import: import { ResourcePanel } from './ResourcePanel';
```

## State of the Art

This is a cleanup phase following feature flag removal best practices documented in 2026.

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Feature toggle for v1.0/v1.1 parallel | v1.1 only, toggle removed | Phase 10.1 (2026-01-25) | Simplifies codebase, reduces testing matrix |
| Optional needs/actionResources | Required properties | Phase 10.1 (2026-01-25) | Better type safety, no runtime undefined checks |
| Flat resource drain (BASE_DRAIN_RATES) | Needs-based asymptotic decay | Phase 7-10 (2026-01) | More realistic simulation, no death spirals |
| Activity resourceEffects | Activity needEffects + difficulty-based costs | Phase 10 (2026-01-24) | Costs emerge from difficulty, personality alignment |

**Deprecated/outdated:**
- **Resources type and Character.resources property**: Replaced by Needs (primary) + DerivedStats (mood/purpose/nutrition) + ActionResources (overskudd/socialBattery/focus/willpower)
- **Activity.resourceEffects**: Replaced by needEffects (direct need restoration) + getResourceCosts (difficulty-scaled costs)
- **needsSystemEnabled toggle**: v1.1 verified complete in Phase 10, no need for parallel systems
- **BASE_DRAIN_RATES / BASE_RECOVERY_RATES constants**: Replaced by need-specific decay rates in balance config
- **Character.activeModifiers (v1.0 personality modifiers)**: Replaced by needsModifiers for v1.1 need decay

## Open Questions

Things that couldn't be fully resolved:

1. **Should boundary state getters be kept or removed?**
   - What we know: `isExhausted`, `isOverstressed`, `isSociallyDrained` exist for v1.0 resources
   - What's unclear: Are these used in any game logic decisions, or just UI badges?
   - Recommendation: Search usages; if only UI, remove and replace with v1.1 equivalents. If used in logic, reimplement using v1.1 properties (needs.energy <= 10, actionResources.socialBattery <= 10).

2. **Data migration for existing saves (if any)?**
   - What we know: Phase goal says "fresh game" success criteria
   - What's unclear: Does the game have save/load yet? Do we need to handle old saves?
   - Recommendation: Verify with codebase. If no save system exists, ignore. If saves exist, add migration to convert v1.0 Resources to v1.1 Needs on load.

3. **Should v1.0 personality modifiers (activeModifiers) be removed?**
   - What we know: activeModifiers computed for Resources drain/recovery, including talent effects
   - What's unclear: Are talents still using resource modifiers, or have they migrated to need modifiers?
   - Recommendation: Check TalentStore and talent data. If talents still target "resources", need to update talent system too. If already migrated to needs, can remove activeModifiers entirely.

## Sources

### Primary (HIGH confidence)
- Codebase inspection - Character.ts, Activity.ts, RootStore.ts, ActivityStore.ts
- Phase 10 verification summary (10-05-SUMMARY.md) - confirms v1.1 system complete and working
- package.json - MobX 6.15.0, TypeScript 5.9.3 versions

### Secondary (MEDIUM confidence)
- [Feature Toggles (aka Feature Flags) - Martin Fowler](https://martinfowler.com/articles/feature-toggles.html) - best practices for removing feature flags
- [How to properly deprecate - DEV Community](https://dev.to/dgreene1/how-to-properly-deprecate-3027) - gradual deprecation process (not needed here, but provides context)
- [Understanding TypeScript Deprecated Properties](https://www.xjavascript.com/blog/typescript-deprecated-property/) - TypeScript deprecation patterns

### Tertiary (LOW confidence)
- [Feature Flag Best Practices - CloudBees](https://www.cloudbees.com/blog/feature-flag-best-practices) - general guidance on flag removal timing
- [TypeScript Migration - W3Schools](https://www.w3schools.com/typescript/typescript_migration.php) - basic migration patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Existing MobX/TypeScript setup, no new dependencies
- Architecture: HIGH - Removal patterns are straightforward, well-documented in feature flag literature
- Pitfalls: HIGH - Based on direct codebase inspection and common TypeScript refactoring gotchas

**Research date:** 2026-01-25
**Valid until:** 60 days (stable - TypeScript patterns don't change rapidly)
