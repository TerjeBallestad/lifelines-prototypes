---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/entities/Character.ts
  - src/entities/types.ts
  - src/stores/CharacterStore.ts
  - src/components/CharacterCard.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "User can see character name displayed on screen"
    - "User can edit character name via input field"
    - "UI updates immediately when character name changes"
    - "Character has placeholder personality, capacities, and resources values"
    - "Computed property (displayName) works correctly"
  artifacts:
    - path: "src/entities/Character.ts"
      provides: "Character entity class with MobX observables"
      exports: ["Character"]
      min_lines: 40
    - path: "src/entities/types.ts"
      provides: "TypeScript interfaces and factory functions for character data"
      exports: ["Personality", "Capacities", "Resources", "defaultPersonality", "defaultCapacities", "defaultResources"]
    - path: "src/components/CharacterCard.tsx"
      provides: "Observable component displaying character state"
      exports: ["CharacterCard"]
    - path: "src/stores/CharacterStore.ts"
      provides: "Updated store with createCharacter method"
      contains: "createCharacter"
  key_links:
    - from: "src/components/CharacterCard.tsx"
      to: "src/stores/index.ts"
      via: "useCharacterStore hook"
      pattern: "useCharacterStore"
    - from: "src/components/CharacterCard.tsx"
      to: "src/entities/Character.ts"
      via: "character.setName call"
      pattern: "character\\.setName"
    - from: "src/stores/CharacterStore.ts"
      to: "src/entities/Character.ts"
      via: "new Character instantiation"
      pattern: "new Character"
    - from: "src/entities/Character.ts"
      to: "mobx"
      via: "makeAutoObservable"
      pattern: "makeAutoObservable"
---

<objective>
Create the Character entity class and proof-of-concept UI that demonstrates full MobX reactivity.

Purpose: Establish the entity pattern (class-based with makeAutoObservable) that all game entities will follow. The CharacterCard proves the full chain: store -> entity -> observable -> React re-render.

Output: Character entity with observable properties, CharacterStore with createCharacter method, and CharacterCard that displays and edits character data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Character entity and type definitions</name>
  <files>
    src/entities/types.ts
    src/entities/Character.ts
  </files>
  <action>
    1. Create src/entities/ directory

    2. Create src/entities/types.ts with interfaces and factory functions:
       ```typescript
       // Big Five personality dimensions
       export interface Personality {
         openness: number;
         conscientiousness: number;
         extraversion: number;
         agreeableness: number;
         neuroticism: number;
       }

       // Mental capacities that affect activity success
       export interface Capacities {
         divergentThinking: number;
         convergentThinking: number;
         workingMemory: number;
         attentionSpan: number;
         processingSpeed: number;
         emotionalRegulation: number;
       }

       // Resources that drain and recover
       export interface Resources {
         energy: number;
         socialBattery: number;
         stressLevel: number;
       }

       // Data required to construct a Character
       export interface CharacterData {
         id: string;
         name: string;
         personality: Personality;
         capacities: Capacities;
         resources: Resources;
       }

       // Factory functions - always return valid defaults (0-100 scale, 50 = average)
       export function defaultPersonality(): Personality {
         return {
           openness: 50,
           conscientiousness: 50,
           extraversion: 50,
           agreeableness: 50,
           neuroticism: 50,
         };
       }

       export function defaultCapacities(): Capacities {
         return {
           divergentThinking: 50,
           convergentThinking: 50,
           workingMemory: 50,
           attentionSpan: 50,
           processingSpeed: 50,
           emotionalRegulation: 50,
         };
       }

       export function defaultResources(): Resources {
         return {
           energy: 100,
           socialBattery: 100,
           stressLevel: 0,
         };
       }
       ```

    3. Create src/entities/Character.ts with class-based entity:
       ```typescript
       import { makeAutoObservable } from 'mobx';
       import type {
         CharacterData,
         Personality,
         Capacities,
         Resources,
       } from './types';

       /**
        * Character entity - the core game object representing a patient.
        * Uses class-based pattern to mirror Unreal Actor structure.
        * All properties are observable, all methods are actions.
        */
       export class Character {
         id: string;
         name: string;
         personality: Personality;
         capacities: Capacities;
         resources: Resources;

         constructor(data: CharacterData) {
           this.id = data.id;
           this.name = data.name;
           this.personality = data.personality;
           this.capacities = data.capacities;
           this.resources = data.resources;

           // Makes all properties observable and all methods actions
           makeAutoObservable(this);
         }

         // Computed: display name with fallback
         get displayName(): string {
           return this.name.trim() || 'Unnamed Character';
         }

         // Computed: basic validation
         get isValid(): boolean {
           return this.name.trim().length > 0;
         }

         // Action: update name
         setName(name: string): void {
           this.name = name;
         }

         // Action: update personality dimensions
         updatePersonality(updates: Partial<Personality>): void {
           Object.assign(this.personality, updates);
         }

         // Action: update capacities
         updateCapacities(updates: Partial<Capacities>): void {
           Object.assign(this.capacities, updates);
         }

         // Action: update resources
         updateResources(updates: Partial<Resources>): void {
           Object.assign(this.resources, updates);
         }
       }
       ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Character class can be instantiated (will test via store in Task 2)
    - Types exported correctly from types.ts
  </verify>
  <done>
    Character entity class created with observable properties, computed getters, and action methods. Type definitions for personality, capacities, and resources established.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update CharacterStore and create CharacterCard UI</name>
  <files>
    src/stores/CharacterStore.ts
    src/components/CharacterCard.tsx
    src/App.tsx
  </files>
  <action>
    1. Update src/stores/CharacterStore.ts with createCharacter:
       ```typescript
       import { makeAutoObservable } from 'mobx';
       import { Character } from '../entities/Character';
       import {
         defaultPersonality,
         defaultCapacities,
         defaultResources,
       } from '../entities/types';
       import type { RootStore } from './RootStore';

       export class CharacterStore {
         character: Character | null = null;

         constructor(private root: RootStore) {
           makeAutoObservable(this);
         }

         // Creates a new character with default values
         createCharacter(name: string): Character {
           this.character = new Character({
             id: crypto.randomUUID(),
             name,
             personality: defaultPersonality(),
             capacities: defaultCapacities(),
             resources: defaultResources(),
           });
           return this.character;
         }

         // Clears the current character
         clearCharacter(): void {
           this.character = null;
         }

         get hasCharacter(): boolean {
           return this.character !== null;
         }
       }
       ```

    2. Create src/components/ directory

    3. Create src/components/CharacterCard.tsx:
       ```typescript
       import { observer } from 'mobx-react-lite';
       import { useCharacterStore } from '../stores';

       export const CharacterCard = observer(function CharacterCard() {
         const store = useCharacterStore();
         const character = store.character;

         if (!character) {
           return (
             <div className="card bg-base-200 shadow-xl max-w-md">
               <div className="card-body">
                 <h2 className="card-title">No Character</h2>
                 <p className="text-base-content/70">
                   Create a character to get started.
                 </p>
                 <div className="card-actions justify-end">
                   <button
                     className="btn btn-primary"
                     onClick={() => store.createCharacter('New Patient')}
                   >
                     Create Character
                   </button>
                 </div>
               </div>
             </div>
           );
         }

         return (
           <div className="card bg-base-200 shadow-xl max-w-md">
             <div className="card-body">
               <h2 className="card-title">{character.displayName}</h2>

               <div className="form-control">
                 <label className="label">
                   <span className="label-text">Name</span>
                 </label>
                 <input
                   type="text"
                   value={character.name}
                   onChange={(e) => character.setName(e.target.value)}
                   placeholder="Enter character name"
                   className="input input-bordered"
                 />
               </div>

               <div className="divider">Status</div>

               <div className="grid grid-cols-2 gap-2 text-sm">
                 <div>
                   <span className="text-base-content/70">Valid:</span>{' '}
                   <span className={character.isValid ? 'text-success' : 'text-error'}>
                     {character.isValid ? 'Yes' : 'No'}
                   </span>
                 </div>
                 <div>
                   <span className="text-base-content/70">Energy:</span>{' '}
                   {character.resources.energy}
                 </div>
                 <div>
                   <span className="text-base-content/70">Social:</span>{' '}
                   {character.resources.socialBattery}
                 </div>
                 <div>
                   <span className="text-base-content/70">Stress:</span>{' '}
                   {character.resources.stressLevel}
                 </div>
               </div>

               <div className="divider">Personality</div>

               <div className="grid grid-cols-2 gap-2 text-sm">
                 <div>O: {character.personality.openness}</div>
                 <div>C: {character.personality.conscientiousness}</div>
                 <div>E: {character.personality.extraversion}</div>
                 <div>A: {character.personality.agreeableness}</div>
                 <div>N: {character.personality.neuroticism}</div>
               </div>

               <div className="card-actions justify-end mt-4">
                 <button
                   className="btn btn-outline btn-error btn-sm"
                   onClick={() => store.clearCharacter()}
                 >
                   Delete
                 </button>
               </div>
             </div>
           </div>
         );
       });
       ```

    4. Update src/App.tsx to use CharacterCard:
       ```typescript
       import { CharacterCard } from './components/CharacterCard';

       function App() {
         return (
           <div className="min-h-screen bg-base-100 p-8">
             <h1 className="text-2xl font-bold text-base-content mb-6">
               Lifelines Prototype
             </h1>

             <CharacterCard />
           </div>
         );
       }

       export default App;
       ```
       Note: App no longer needs observer() wrapper since it doesn't directly read observables.
  </action>
  <verify>
    - `npm run dev` starts without errors
    - Page shows "No Character" card with "Create Character" button
    - Clicking "Create Character" shows character details card
    - Typing in name input updates the card title immediately (proves MobX reactivity)
    - Clearing name shows "Unnamed Character" as title (proves computed getter)
    - Browser console shows MobX actions when interacting
    - "Delete" button returns to "No Character" state
  </verify>
  <done>
    CharacterStore has createCharacter/clearCharacter methods. CharacterCard displays and edits character. Full MobX reactivity chain proven: input -> action -> observable -> computed -> re-render.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npm run dev` starts the dev server
2. Click "Create Character" -> character card appears with "New Patient" name
3. Edit name in input -> card title updates in real-time
4. Clear name -> title shows "Unnamed Character" (computed getter)
5. Delete character -> returns to "No Character" state
6. Console shows MobX action logs for all interactions
7. `npm run lint` passes
8. `npx tsc --noEmit` passes
</verification>

<success_criteria>
- Character entity class exists with makeAutoObservable
- Character has observable properties: id, name, personality, capacities, resources
- Character has computed getters: displayName, isValid
- Character has action methods: setName, updatePersonality, updateCapacities, updateResources
- CharacterStore has createCharacter and clearCharacter methods
- CharacterCard displays character state and allows name editing
- UI updates immediately when character state changes (no manual refresh)
- Full MobX reactivity chain working: user input -> action -> observable -> computed -> re-render
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
