---
phase: 12-tuning-balance
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/balance.ts
  - src/components/DevToolsPanel.tsx
  - src/utils/presets.ts
autonomous: true

must_haves:
  truths:
    - "Balance config persists across page refresh"
    - "Player can save named presets"
    - "Player can load saved presets"
    - "Player can tune decay rates and formula weights via UI"
    - "Player can reset to defaults"
  artifacts:
    - path: "src/config/balance.ts"
      provides: "BalanceConfigStore with localStorage persistence"
      contains: "localStorage"
    - path: "src/utils/presets.ts"
      provides: "Preset save/load utilities"
      exports: ["savePreset", "loadPreset", "listPresets", "deletePreset"]
    - path: "src/components/DevToolsPanel.tsx"
      provides: "Extended UI with preset controls and deep config editing"
      min_lines: 200
  key_links:
    - from: "src/config/balance.ts"
      to: "localStorage"
      via: "MobX reaction auto-saving"
      pattern: "localStorage\\.setItem"
    - from: "src/components/DevToolsPanel.tsx"
      to: "src/utils/presets.ts"
      via: "import and function calls"
      pattern: "savePreset|loadPreset"
---

<objective>
Extend BalanceConfigStore with localStorage persistence and preset system for runtime tuning.

Purpose: Enables balance tuning without code changes, with presets for A/B testing different balance philosophies.
Output: Config persists across refresh, presets can be saved/loaded, DevToolsPanel has full config editing.
</objective>

<execution_context>
@/Users/godstemning/.claude/get-shit-done/workflows/execute-plan.md
@/Users/godstemning/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-tuning-balance/12-CONTEXT.md
@.planning/phases/12-tuning-balance/12-RESEARCH.md

# Existing patterns
@src/config/balance.ts (BalanceConfigStore to extend)
@src/components/DevToolsPanel.tsx (existing DevTools UI)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add localStorage persistence to BalanceConfigStore</name>
  <files>src/config/balance.ts</files>
  <action>
Extend BalanceConfigStore with localStorage persistence:

1. Add storage key constants:
   - `BALANCE_CONFIG_KEY = 'balance-config'`
   - `BALANCE_PRESETS_KEY = 'balance-presets'`

2. In constructor:
   - Load saved config from localStorage if exists
   - Use JSON.parse with try/catch for safety
   - Fall back to DEFAULT_BALANCE if parse fails

3. Add MobX reaction to auto-save on changes:
   ```typescript
   reaction(
     () => JSON.stringify(this.config),
     (configJson) => {
       localStorage.setItem(BALANCE_CONFIG_KEY, configJson);
     },
     { delay: 500 } // Debounce 500ms
   );
   ```

4. Add import for `reaction` from mobx

5. Use `makeAutoObservable(this, {}, { deep: true })` to ensure nested object changes trigger reactivity

Important: Deep observe the entire config object so nested updates (e.g., config.needs.hungerDecayRate) trigger saves.
  </action>
  <verify>Change a balance value, refresh page, value persists.</verify>
  <done>BalanceConfigStore auto-saves to localStorage on changes and loads on init.</done>
</task>

<task type="auto">
  <name>Task 2: Create preset utilities</name>
  <files>src/utils/presets.ts</files>
  <action>
Create preset management utilities:

```typescript
import type { BalanceConfig } from '../config/balance';

const BALANCE_PRESETS_KEY = 'balance-presets';

export type PresetMap = Record<string, BalanceConfig>;

export function listPresets(): string[] {
  const stored = localStorage.getItem(BALANCE_PRESETS_KEY);
  if (!stored) return [];
  try {
    return Object.keys(JSON.parse(stored) as PresetMap);
  } catch {
    return [];
  }
}

export function savePreset(name: string, config: BalanceConfig): void {
  const presets = loadAllPresets();
  presets[name] = config;
  localStorage.setItem(BALANCE_PRESETS_KEY, JSON.stringify(presets));
}

export function loadPreset(name: string): BalanceConfig | null {
  const presets = loadAllPresets();
  return presets[name] ?? null;
}

export function deletePreset(name: string): void {
  const presets = loadAllPresets();
  delete presets[name];
  localStorage.setItem(BALANCE_PRESETS_KEY, JSON.stringify(presets));
}

function loadAllPresets(): PresetMap {
  const stored = localStorage.getItem(BALANCE_PRESETS_KEY);
  if (!stored) return {};
  try {
    return JSON.parse(stored) as PresetMap;
  } catch {
    return {};
  }
}

// Export/import for file-based backup
export function exportPresetsToJSON(): string {
  return localStorage.getItem(BALANCE_PRESETS_KEY) ?? '{}';
}

export function importPresetsFromJSON(json: string): boolean {
  try {
    JSON.parse(json); // Validate
    localStorage.setItem(BALANCE_PRESETS_KEY, json);
    return true;
  } catch {
    return false;
  }
}
```
  </action>
  <verify>File exists and exports all functions. TypeScript compiles.</verify>
  <done>Preset utilities allow saving, loading, listing, and deleting named presets.</done>
</task>

<task type="auto">
  <name>Task 3: Extend DevToolsPanel with presets and deep config</name>
  <files>src/components/DevToolsPanel.tsx</files>
  <action>
Extend DevToolsPanel with:

1. **Preset controls section** (at top):
   - Dropdown to select from saved presets (listPresets())
   - "Load" button to apply selected preset
   - Text input for new preset name
   - "Save Current" button to save current config as preset
   - "Delete" button for selected preset

2. **Nested config sections** using collapsible `<details>`:
   - **Needs Config**: All 7 decay rates + personalityModifierNeeds + criticalThreshold
   - **Derived Stats Config**: Mood (alpha, floor, ceiling, needWeights), Purpose (alpha, decayRate, equilibriumWeights), Nutrition (alpha, energyMods, moodPenalty)
   - **Action Resources Config**: Overskudd (alpha, weights), socialBattery (alpha, rates), Focus (alpha, rates), Willpower (alpha, rates, costs)
   - **Difficulty Config**: maxSkillReduction, maxMasteryReduction

3. Use helper function for nested updates:
   ```typescript
   const handleNestedUpdate = (section: 'needs' | 'derivedStats' | 'actionResources' | 'difficulty', field: string, value: number) => {
     const sectionConfig = { ...balanceConfig.config[section], [field]: value };
     balanceConfig.update({ [section]: sectionConfig });
   };
   ```

4. Add import for preset utilities

5. Use React.useState for:
   - selectedPreset (string)
   - newPresetName (string)
   - presetList (string[]) - refresh on save/delete

Layout: Presets at top, then collapsible sections for each config area.
  </action>
  <verify>`npm run build` succeeds. DevToolsPanel shows preset controls and all nested config fields.</verify>
  <done>DevToolsPanel allows preset save/load and editing all balance parameters including nested config.</done>
</task>

</tasks>

<verification>
- Change hungerDecayRate in DevTools, refresh page, value persists
- Save preset as "fast-decay", change values, load "fast-decay", original values restored
- Delete preset removes it from list
- All nested config fields (needs, derivedStats, actionResources, difficulty) editable
- Reset to Defaults still works
</verification>

<success_criteria>
- Balance config persists across browser refresh via localStorage
- Presets can be saved with custom names
- Presets can be loaded to restore previous configs
- All decay rates and formula weights editable via DevToolsPanel
- Reset to Defaults clears localStorage config
</success_criteria>

<output>
After completion, create `.planning/phases/12-tuning-balance/12-02-SUMMARY.md`
</output>
