---
phase: 12-tuning-balance
plan: 03
type: execute
wave: 2
depends_on: ["12-02"]
files_modified:
  - src/stores/TelemetryStore.ts
  - src/utils/headlessSimulation.ts
  - src/stores/RootStore.ts
autonomous: true

must_haves:
  truths:
    - "Simulation can run headless without React rendering"
    - "Telemetry captures needs, derived stats, action resources per tick"
    - "Long simulations don't block UI (yield to event loop)"
    - "Multiple simulation configurations can be run"
  artifacts:
    - path: "src/stores/TelemetryStore.ts"
      provides: "MobX store for capturing simulation telemetry"
      exports: ["TelemetryStore", "TelemetryDataPoint"]
    - path: "src/utils/headlessSimulation.ts"
      provides: "Headless simulation runner utility"
      exports: ["runHeadlessSimulation", "HeadlessSimulationConfig", "HeadlessSimulationResult"]
    - path: "src/stores/RootStore.ts"
      provides: "TelemetryStore integration"
      contains: "telemetryStore"
  key_links:
    - from: "src/utils/headlessSimulation.ts"
      to: "src/stores/TelemetryStore.ts"
      via: "recording tick data"
      pattern: "telemetryStore\\.recordTick"
    - from: "src/utils/headlessSimulation.ts"
      to: "src/stores/SimulationStore.ts"
      via: "tick() method for simulation"
      pattern: "\\.tick\\("
---

<objective>
Create headless simulation runner with telemetry capture for balance validation testing.

Purpose: Enables running 7-day simulations in background to validate autonomous patient survival and personality differentiation.
Output: TelemetryStore capturing time-series data, headless simulation utility that runs without React rendering.
</objective>

<execution_context>
@/Users/godstemning/.claude/get-shit-done/workflows/execute-plan.md
@/Users/godstemning/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-tuning-balance/12-CONTEXT.md
@.planning/phases/12-tuning-balance/12-RESEARCH.md

# Existing patterns
@src/stores/SimulationStore.ts (tick() method)
@src/stores/RootStore.ts (store structure)
@src/entities/Character.ts (state to capture)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TelemetryStore</name>
  <files>src/stores/TelemetryStore.ts</files>
  <action>
Create TelemetryStore for capturing simulation telemetry:

```typescript
import { makeAutoObservable, action } from 'mobx';
import type { Character } from '../entities/Character';
import type { NeedKey } from '../entities/types';

export interface TelemetryDataPoint {
  tick: number;
  timestamp: number;
  characterId: string;
  // Primary needs
  hunger: number;
  energy: number;
  hygiene: number;
  bladder: number;
  social: number;
  fun: number;
  security: number;
  // Derived wellbeing
  mood: number;
  purpose: number;
  nutrition: number;
  // Action resources
  overskudd: number;
  socialBattery: number;
  focus: number;
  willpower: number;
  // Activity info
  currentActivity: string | null;
  criticalNeeds: NeedKey[];
}

export interface TelemetryRun {
  id: string;
  characterName: string;
  personality: { extraversion: number; openness: number; conscientiousness: number };
  startTime: number;
  endTime?: number;
  tickCount: number;
  data: TelemetryDataPoint[];
}

export class TelemetryStore {
  runs: TelemetryRun[] = [];
  activeRun: TelemetryRun | null = null;

  constructor() {
    makeAutoObservable(this, {
      startRun: action,
      recordTick: action,
      endRun: action,
      clearRuns: action,
    });
  }

  startRun(character: Character): void {
    this.activeRun = {
      id: `run-${Date.now()}`,
      characterName: character.name,
      personality: {
        extraversion: character.personality.extraversion,
        openness: character.personality.openness,
        conscientiousness: character.personality.conscientiousness,
      },
      startTime: Date.now(),
      tickCount: 0,
      data: [],
    };
  }

  recordTick(character: Character, tick: number, currentActivity: string | null): void {
    if (!this.activeRun) return;

    const criticalNeeds: NeedKey[] = [];
    const criticalThreshold = 20;
    for (const key of ['hunger', 'energy', 'hygiene', 'bladder', 'social', 'fun', 'security'] as NeedKey[]) {
      if (character.needs[key] < criticalThreshold) {
        criticalNeeds.push(key);
      }
    }

    const point: TelemetryDataPoint = {
      tick,
      timestamp: Date.now(),
      characterId: character.id,
      hunger: character.needs.hunger,
      energy: character.needs.energy,
      hygiene: character.needs.hygiene,
      bladder: character.needs.bladder,
      social: character.needs.social,
      fun: character.needs.fun,
      security: character.needs.security,
      mood: character.derivedStats.mood,
      purpose: character.derivedStats.purpose,
      nutrition: character.derivedStats.nutrition,
      overskudd: character.actionResources.overskudd,
      socialBattery: character.actionResources.socialBattery,
      focus: character.actionResources.focus,
      willpower: character.actionResources.willpower,
      currentActivity,
      criticalNeeds,
    };

    this.activeRun.data.push(point);
    this.activeRun.tickCount = tick;
  }

  endRun(): TelemetryRun | null {
    if (!this.activeRun) return null;
    this.activeRun.endTime = Date.now();
    const completedRun = this.activeRun;
    this.runs.push(completedRun);
    this.activeRun = null;
    return completedRun;
  }

  clearRuns(): void {
    this.runs = [];
    this.activeRun = null;
  }

  // Computed: Get run statistics
  getRunStats(run: TelemetryRun): {
    minNeeds: Record<NeedKey, number>;
    avgMood: number;
    criticalEvents: number;
  } {
    const needs: NeedKey[] = ['hunger', 'energy', 'hygiene', 'bladder', 'social', 'fun', 'security'];
    const minNeeds = {} as Record<NeedKey, number>;
    for (const need of needs) {
      minNeeds[need] = Math.min(...run.data.map(d => d[need]));
    }
    const avgMood = run.data.reduce((sum, d) => sum + d.mood, 0) / run.data.length;
    const criticalEvents = run.data.filter(d => d.criticalNeeds.length > 0).length;
    return { minNeeds, avgMood, criticalEvents };
  }
}
```
  </action>
  <verify>File exists, exports TelemetryStore and TelemetryDataPoint. TypeScript compiles.</verify>
  <done>TelemetryStore captures per-tick simulation data with run management.</done>
</task>

<task type="auto">
  <name>Task 2: Create headless simulation runner</name>
  <files>src/utils/headlessSimulation.ts</files>
  <action>
Create headless simulation runner that ticks stores without React rendering:

```typescript
import { RootStore } from '../stores/RootStore';
import { TelemetryStore, TelemetryRun } from '../stores/TelemetryStore';
import type { BalanceConfig } from '../config/balance';
import type { BigFiveTraits } from '../entities/types';

export interface HeadlessSimulationConfig {
  /** Number of ticks to simulate (7 days = 7 * 24 * 60 = 10080 at 1 tick/min) */
  ticks: number;
  /** Balance config to use (null = use current) */
  balanceConfig?: BalanceConfig;
  /** Personality override for character */
  personality?: Partial<BigFiveTraits>;
  /** Sample rate: record every Nth tick (1 = all, 10 = every 10th) */
  sampleRate?: number;
  /** Character name for run identification */
  characterName?: string;
}

export interface HeadlessSimulationResult {
  run: TelemetryRun;
  success: boolean;
  failureReason?: string;
  stats: {
    minNeeds: Record<string, number>;
    avgMood: number;
    criticalEvents: number;
    survivalRate: number; // % of ticks with no critical needs
  };
}

/**
 * Run a headless simulation without React rendering.
 * Yields to event loop every 100 ticks to prevent UI blocking.
 */
export async function runHeadlessSimulation(
  rootStore: RootStore,
  config: HeadlessSimulationConfig
): Promise<HeadlessSimulationResult> {
  const { ticks, balanceConfig, personality, sampleRate = 1, characterName } = config;

  // Apply balance config if provided
  if (balanceConfig) {
    rootStore.balanceConfig.update(balanceConfig);
  }

  // Get or create character
  let character = rootStore.characterStore.character;
  if (!character) {
    return {
      run: null as unknown as TelemetryRun,
      success: false,
      failureReason: 'No character available',
      stats: { minNeeds: {}, avgMood: 0, criticalEvents: 0, survivalRate: 0 },
    };
  }

  // Apply personality override if provided
  if (personality) {
    Object.assign(character.personality, personality);
  }

  // Enable autonomous mode
  character.freeWill = true;

  // Start telemetry run
  rootStore.telemetryStore.startRun(character);

  // Run simulation
  for (let i = 0; i < ticks; i++) {
    // Tick simulation (this updates character state and triggers AI)
    rootStore.simulationStore.tick();

    // Record telemetry at sample rate
    if (i % sampleRate === 0) {
      const currentActivity = rootStore.activityStore.currentActivityForCharacter(character.id)?.activity.name ?? null;
      rootStore.telemetryStore.recordTick(character, i, currentActivity);
    }

    // Yield to event loop every 100 ticks to keep UI responsive
    if (i % 100 === 0) {
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }

  // End run and get stats
  const run = rootStore.telemetryStore.endRun()!;
  const stats = rootStore.telemetryStore.getRunStats(run);

  // Calculate survival rate
  const survivalRate = 1 - (stats.criticalEvents / run.data.length);

  return {
    run,
    success: survivalRate > 0.9, // 90%+ survival = success
    stats: { ...stats, survivalRate },
  };
}

/**
 * 7 in-game days at 1 tick per minute = 10080 ticks.
 * Use sample rate 10 to capture 1008 data points.
 */
export const SEVEN_DAYS_TICKS = 7 * 24 * 60;
export const DEFAULT_SAMPLE_RATE = 10;
```
  </action>
  <verify>File exists, exports runHeadlessSimulation and constants. TypeScript compiles.</verify>
  <done>Headless simulation runner can tick stores without rendering, with async yielding.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate TelemetryStore into RootStore</name>
  <files>src/stores/RootStore.ts</files>
  <action>
Add TelemetryStore to RootStore:

1. Import TelemetryStore
2. Add property: `telemetryStore: TelemetryStore`
3. Initialize in constructor: `this.telemetryStore = new TelemetryStore()`
4. Add to context type if using React context pattern

Also add helper method to ActivityStore or RootStore for getting current activity by character ID (if not exists):
- `currentActivityForCharacter(characterId: string)` - returns active item from queue or null

Check if this method already exists in ActivityStore. If not, add it to support telemetry recording.
  </action>
  <verify>`npm run build` succeeds. TelemetryStore accessible via rootStore.telemetryStore.</verify>
  <done>TelemetryStore integrated into RootStore and accessible throughout app.</done>
</task>

</tasks>

<verification>
- TelemetryStore records data points with all needs, derived stats, action resources
- runHeadlessSimulation completes 1000 ticks without blocking UI
- Sample rate works (sampleRate=10 produces 1/10th data points)
- Run stats computed correctly (min needs, avg mood, critical events)
- No TypeScript errors
</verification>

<success_criteria>
- Headless simulation runs 10,000+ ticks without UI freeze
- Telemetry captures all character state per sampled tick
- Multiple runs can be stored for comparison
- Run statistics computed (min needs, avg mood, survival rate)
</success_criteria>

<output>
After completion, create `.planning/phases/12-tuning-balance/12-03-SUMMARY.md`
</output>
