---
phase: 10-activity-need-integration
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/entities/Activity.ts
  - src/data/activities.ts
autonomous: true

must_haves:
  truths:
    - "Activity can calculate resource costs based on effective difficulty"
    - "Difficulty maps to costs linearly (1:1)"
    - "Personality alignment reduces costs for aligned activities"
    - "All starter activities have appropriate tags and need effects"
  artifacts:
    - path: "src/entities/Activity.ts"
      provides: "getResourceCosts method"
      contains: "getResourceCosts"
    - path: "src/data/activities.ts"
      provides: "Activities with tags and needEffects"
      contains: "tags:"
  key_links:
    - from: "src/entities/Activity.ts"
      to: "src/utils/personalityFit.ts"
      via: "import calculatePersonalityAlignment"
      pattern: "import.*personalityFit"
    - from: "Activity.getResourceCosts"
      to: "Activity.getEffectiveDifficulty"
      via: "difficulty-based cost calculation"
      pattern: "getEffectiveDifficulty"
---

<objective>
Add resource cost calculation to Activity and update starter activities with tags and need effects.

Purpose: Enable activities to compute their resource costs based on difficulty, skills, mastery, and personality alignment. Populate starter activities with meaningful tags and need restoration effects.

Output: Activity.getResourceCosts() method and enriched STARTER_ACTIVITIES data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-activity-need-integration/10-CONTEXT.md
@.planning/phases/10-activity-need-integration/10-RESEARCH.md
@.planning/phases/10-activity-need-integration/10-01-SUMMARY.md

@src/entities/Activity.ts
@src/entities/Character.ts
@src/data/activities.ts
@src/utils/personalityFit.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getResourceCosts method to Activity</name>
  <files>src/entities/Activity.ts</files>
  <action>
Import calculatePersonalityAlignment from '../utils/personalityFit'.

Add new interface (can be in Activity.ts or a types file):
```typescript
interface ResourceCosts {
  overskudd: number;        // Required to start, consumed during
  willpower: number;        // Consumed at activity start
  focus: number;            // Consumed during (concentration activities)
  socialBattery: number;    // Consumed during (social activities)
  alignment: ActivityAlignment;  // For tooltip display
}
```

Add method to Activity class:
```typescript
/**
 * Calculate resource costs for this activity based on difficulty and personality.
 * Costs scale linearly with effective difficulty (1:1 mapping).
 * Personality alignment reduces costs for well-matched activities.
 *
 * CONTEXT.md rules:
 * - Difficulty maps to costs linearly (1:1)
 * - No minimum cost floor (mastered activities can become nearly free)
 * - Overskudd: visible, required to start, consumed during
 * - Willpower: consumed at start
 * - Focus: consumed during concentration activities
 * - socialBattery: consumed during social activities
 */
getResourceCosts(character: Character): ResourceCosts
```

Implementation:
1. Get effective difficulty using existing getEffectiveDifficulty(character)
2. Calculate base costs from difficulty:
   - baseCost = effectiveDifficulty * 5 (difficulty 1 = 5 cost, difficulty 5 = 25 cost)
   - overskudd = baseCost (full scaling)
   - willpower = baseCost * 0.5
   - focus = hasTag('concentration') ? baseCost * 0.3 : 0
   - socialBattery = hasTag('social') ? baseCost * 0.4 : 0
3. Get personality alignment using calculatePersonalityAlignment(this.tags, character.personality)
4. Apply alignment.costMultiplier to all non-zero costs
5. Return ResourceCosts with alignment for tooltip display

Helper method (private):
```typescript
private hasTag(tag: string): boolean {
  return this.tags?.includes(tag) ?? false;
}
```

Store tags from ActivityData in constructor:
```typescript
readonly tags?: string[];  // Add to class properties
this.tags = data.tags;     // Add to constructor
```

Also store needEffects:
```typescript
readonly needEffects?: Partial<Record<NeedKey, number>>;
this.needEffects = data.needEffects;
```
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Method exists: `grep -l "getResourceCosts" src/entities/Activity.ts`
  </verify>
  <done>Activity class has getResourceCosts(character) method that calculates costs based on effective difficulty with personality alignment modifier</done>
</task>

<task type="auto">
  <name>Task 2: Update STARTER_ACTIVITIES with tags and needEffects</name>
  <files>src/data/activities.ts</files>
  <action>
Update each activity in STARTER_ACTIVITIES to include:
1. `tags` - personality alignment tags
2. `needEffects` - per-tick need restoration

Tag assignments (based on activity nature):
- chat-with-neighbor: ['social']
- phone-call-practice: ['social', 'stressful', 'concentration']
- plan-tomorrow: ['routine', 'concentration']
- tidy-room: ['routine']
- go-for-walk: ['solo']
- visit-store: ['social', 'stressful']
- rest: ['solo'] (basic need - no tags needed, but solo for introverts)
- solo-hobby: ['solo', 'creative']

Need effects assignments (per-tick restoration, scaled for 20-45 tick durations):
- chat-with-neighbor: { social: 2 } (small social boost)
- phone-call-practice: { social: 1.5 } (less than in-person)
- plan-tomorrow: { security: 1 } (planning creates security)
- tidy-room: { hygiene: 1, security: 0.5 } (clean space, sense of control)
- go-for-walk: { fun: 0.5, energy: -0.5 } (enjoyable but tiring - already has energy in resourceEffects, so skip)
  Actually: { fun: 1 } (just fun, energy handled by resourceEffects)
- visit-store: { hunger: 3 } (getting food restores hunger planning)
  Wait - visiting store doesn't restore hunger immediately. Skip needEffects for this one.
  Actually: {} (no immediate need restoration - you buy food, don't eat it)
- rest: { energy: 3 } (resting restores energy need - but this overlaps with resourceEffects.energy)
  Since v1.1 needs are separate from v1.0 resources, both can exist.
  { energy: 3 } (restores the primary need Energy/sleep satisfaction)
- solo-hobby: { fun: 2 } (entertainment satisfaction)

Important: needEffects targets v1.1 Needs (hunger, energy, hygiene, bladder, social, fun, security)
while resourceEffects targets v1.0 Resources (energy, socialBattery, stress, etc.)
They are different systems with some overlap in naming.

Verify NeedKey is imported if needed for type safety.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Tags present: `grep -c "tags:" src/data/activities.ts` shows 8 (one per activity)
  </verify>
  <done>All 8 starter activities have appropriate tags and needEffects defined for personality alignment and need restoration</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Activity.getResourceCosts returns costs scaled by difficulty and alignment
3. All 8 STARTER_ACTIVITIES have tags array
4. Relevant activities have needEffects for need restoration
</verification>

<success_criteria>
- Activity.getResourceCosts(character) returns ResourceCosts with difficulty-scaled, alignment-adjusted costs
- All starter activities tagged for personality alignment
- Activities that restore needs have needEffects defined
- Ready for Plan 03 to integrate costs/restoration into ActivityStore
</success_criteria>

<output>
After completion, create `.planning/phases/10-activity-need-integration/10-02-SUMMARY.md`
</output>
