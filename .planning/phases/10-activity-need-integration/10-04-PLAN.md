---
phase: 10-activity-need-integration
plan: 04
type: execute
wave: 3
depends_on: ["10-02"]
files_modified:
  - src/components/FloatingNumber.tsx
  - src/components/ActivityCard.tsx
  - src/stores/ActivityStore.ts
  - tailwind.config.js
autonomous: true

must_haves:
  truths:
    - "Floating numbers appear during activity showing need restoration"
    - "Completion toast summarizes all changes from activity"
    - "Activity card tooltip shows estimated costs based on difficulty"
    - "Personality alignment visible in tooltip (not on card face)"
  artifacts:
    - path: "src/components/FloatingNumber.tsx"
      provides: "Animated floating feedback component"
      exports: ["FloatingNumber"]
    - path: "src/components/ActivityCard.tsx"
      provides: "Cost tooltip on activity cards"
      contains: "getResourceCosts"
  key_links:
    - from: "ActivityStore"
      to: "FloatingNumber rendering"
      via: "floating number events"
      pattern: "floatingNumbers"
    - from: "ActivityCard"
      to: "Activity.getResourceCosts"
      via: "tooltip cost display"
      pattern: "getResourceCosts"
---

<objective>
Implement UI feedback for activity execution: floating numbers during activity, completion summary toast, and cost tooltips on activity cards.

Purpose: Players see clear cause-effect between activities and need/resource changes, can evaluate activity costs before starting.

Output: FloatingNumber component, enhanced ActivityCard tooltip, enriched completion toast.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-activity-need-integration/10-CONTEXT.md
@.planning/phases/10-activity-need-integration/10-RESEARCH.md
@.planning/phases/10-activity-need-integration/10-02-SUMMARY.md

@src/components/ActivityCard.tsx
@src/stores/ActivityStore.ts
@tailwind.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FloatingNumber component and animation</name>
  <files>src/components/FloatingNumber.tsx, tailwind.config.js</files>
  <action>
Create FloatingNumber.tsx:

```typescript
import clsx from 'clsx';

interface FloatingNumberProps {
  id: string;
  value: number;
  label: string;
  onComplete: (id: string) => void;
}

/**
 * Animated floating number that shows resource/need changes.
 * Floats upward and fades out over 1.5s.
 */
export function FloatingNumber({ id, value, label, onComplete }: FloatingNumberProps) {
  const isPositive = value > 0;
  const prefix = isPositive ? '+' : '';
  const displayValue = Math.abs(value) >= 1 ? value.toFixed(0) : value.toFixed(1);

  return (
    <div
      className="pointer-events-none animate-float-up absolute"
      onAnimationEnd={() => onComplete(id)}
    >
      <span
        className={clsx(
          'text-sm font-bold drop-shadow-md',
          isPositive ? 'text-success' : 'text-error'
        )}
      >
        {prefix}{displayValue} {label}
      </span>
    </div>
  );
}
```

Add animation to tailwind.config.js:

In the `extend` section, add:
```javascript
animation: {
  'float-up': 'float-up 1.5s ease-out forwards',
},
keyframes: {
  'float-up': {
    '0%': { transform: 'translateY(0)', opacity: '1' },
    '100%': { transform: 'translateY(-40px)', opacity: '0' },
  },
},
```

Note: If tailwind.config.js already has animation/keyframes, merge with existing.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Component exists: `ls src/components/FloatingNumber.tsx`
3. Animation defined: `grep -l "float-up" tailwind.config.js`
  </verify>
  <done>FloatingNumber component renders animated +/- feedback with float-up animation</done>
</task>

<task type="auto">
  <name>Task 2: Add floating number state to ActivityStore</name>
  <files>src/stores/ActivityStore.ts</files>
  <action>
Add floating number management to ActivityStore for UI to consume.

Add interface and state:
```typescript
interface FloatingNumberData {
  id: string;
  value: number;
  label: string;
  timestamp: number;
}

// In ActivityStore class:
floatingNumbers = observable.array<FloatingNumberData>();
```

Add method to emit floating numbers:
```typescript
/**
 * Emit a floating number for UI display.
 * Numbers auto-expire after 2 seconds.
 */
private emitFloatingNumber(label: string, value: number): void {
  // Only emit if change is significant (>= 0.5)
  if (Math.abs(value) < 0.5) return;

  this.floatingNumbers.push({
    id: `${label}-${Date.now()}-${Math.random()}`,
    value,
    label,
    timestamp: Date.now(),
  });

  // Auto-cleanup after 2 seconds
  setTimeout(() => {
    this.cleanupExpiredFloatingNumbers();
  }, 2000);
}

/**
 * Remove expired floating numbers.
 */
cleanupExpiredFloatingNumbers(): void {
  const now = Date.now();
  const expired = this.floatingNumbers.filter(fn => now - fn.timestamp > 2000);
  expired.forEach(fn => {
    const index = this.floatingNumbers.indexOf(fn);
    if (index >= 0) this.floatingNumbers.splice(index, 1);
  });
}

/**
 * Remove a specific floating number by id.
 * Called by UI when animation completes.
 */
removeFloatingNumber(id: string): void {
  const index = this.floatingNumbers.findIndex(fn => fn.id === id);
  if (index >= 0) this.floatingNumbers.splice(index, 1);
}
```

In applyResourceEffects, after updating needs (from 10-03), emit floating numbers:
```typescript
// After updating character.needs[key]
if (Math.abs(restore) >= 0.5) {
  this.emitFloatingNumber(needKey, restore);
}
```

Batch/throttle consideration: For now, emit individual numbers. If performance becomes an issue, we can batch multiple changes. RESEARCH.md recommends starting simple.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. FloatingNumbers observable: `grep -l "floatingNumbers" src/stores/ActivityStore.ts`
  </verify>
  <done>ActivityStore tracks floating numbers for UI consumption with auto-cleanup</done>
</task>

<task type="auto">
  <name>Task 3: Update ActivityCard with cost tooltip and completion summary</name>
  <files>src/components/ActivityCard.tsx, src/stores/ActivityStore.ts</files>
  <action>
**Part A: Update ActivityCard tooltip to show costs**

In ActivityCard.tsx, for preview variant, add a costs section to the card or tooltip.

If activity is an Activity instance and character is provided, call getResourceCosts:
```typescript
// After difficulty calculation
let costs: ResourceCosts | undefined;
let alignmentInfo: ActivityAlignment | undefined;

if (activity instanceof Activity && character) {
  const resourceCosts = activity.getResourceCosts(character);
  costs = resourceCosts;
  alignmentInfo = resourceCosts.alignment;
}
```

Add cost display in the card body (after resource effects preview):
```typescript
{/* Estimated costs (if available) */}
{variant === 'preview' && costs && (
  <div className="mt-1 text-xs text-base-content/60">
    <span className="font-medium">Costs:</span>{' '}
    <span>Overskudd -{costs.overskudd.toFixed(0)}</span>
    {costs.willpower > 0 && <span>, Willpower -{costs.willpower.toFixed(0)}</span>}
    {costs.focus > 0 && <span>, Focus -{costs.focus.toFixed(0)}</span>}
    {costs.socialBattery > 0 && <span>, Social -{costs.socialBattery.toFixed(0)}</span>}
  </div>
)}

{/* Personality alignment indicator (tooltip only - card stays clean per CONTEXT.md) */}
{variant === 'preview' && alignmentInfo && alignmentInfo.breakdown.length > 0 && (
  <div
    className="mt-1 text-xs opacity-50 cursor-help"
    title={alignmentInfo.breakdown.map(b => `${b.trait}: ${b.contribution > 0 ? '+' : ''}${(b.contribution * 100).toFixed(0)}%`).join(', ')}
  >
    {alignmentInfo.costMultiplier < 0.95 ? '(Good fit)' : alignmentInfo.costMultiplier > 1.05 ? '(Poor fit)' : ''}
  </div>
)}
```

Import ResourceCosts type from Activity.ts if needed.

**Part B: Enhance completion toast in ActivityStore**

In completeActivity method, add a summary of changes.

Track cumulative changes during activity execution by storing totals:
```typescript
// Add to class state
private activityEffectTotals: Map<string, number> = new Map();

// At activity start (in tryStartNextActivity when activity becomes current)
this.activityEffectTotals.clear();

// In applyResourceEffects, track cumulative changes
// After applying each effect:
const current = this.activityEffectTotals.get(key) ?? 0;
this.activityEffectTotals.set(key, current + effect);
```

In completeActivity, use the totals to build summary:
```typescript
// Build summary description
const significantChanges = Array.from(this.activityEffectTotals.entries())
  .filter(([_, val]) => Math.abs(val) >= 1)
  .map(([key, val]) => {
    const sign = val >= 0 ? '+' : '';
    return `${key}: ${sign}${val.toFixed(0)}`;
  })
  .slice(0, 4); // Max 4 changes to keep toast readable

const description = significantChanges.length > 0
  ? significantChanges.join(', ')
  : undefined;

toast.success(`Completed: ${activity.name}!`, {
  description,
  duration: 3000,
});
```
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Cost display in ActivityCard: `grep -l "Costs:" src/components/ActivityCard.tsx`
3. Effect totals tracked: `grep -l "activityEffectTotals" src/stores/ActivityStore.ts`
  </verify>
  <done>ActivityCard shows estimated costs, completion toast summarizes resource changes</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. FloatingNumber component renders with animation
3. ActivityStore emits floating numbers during activity
4. ActivityCard preview variant shows cost estimates
5. Completion toast includes resource change summary
</verification>

<success_criteria>
- Floating numbers appear during activity showing need restoration (+5 Hunger style)
- Completion toast shows summary of resource changes
- Activity card tooltips display estimated costs based on difficulty and skills
- Personality alignment visible in tooltip (not cluttering card face)
- UI feedback makes cause-effect relationship clear
</success_criteria>

<output>
After completion, create `.planning/phases/10-activity-need-integration/10-04-SUMMARY.md`
</output>
