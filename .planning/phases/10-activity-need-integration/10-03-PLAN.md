---
phase: 10-activity-need-integration
plan: 03
type: execute
wave: 3
depends_on: ["10-02"]
files_modified:
  - src/stores/ActivityStore.ts
autonomous: true

must_haves:
  truths:
    - "Activities restore needs gradually during execution"
    - "If activity is interrupted, patient keeps partial need restoration"
    - "Difficulty affects resource costs (higher difficulty = more drain)"
    - "Personality alignment modifies both costs and gains"
    - "Struggling patients (critical needs <20%) get reduced costs"
  artifacts:
    - path: "src/stores/ActivityStore.ts"
      provides: "Need restoration and cost integration"
      contains: "needEffects"
  key_links:
    - from: "ActivityStore.applyResourceEffects"
      to: "Activity.needEffects"
      via: "per-tick need restoration"
      pattern: "needEffects"
    - from: "ActivityStore.applyResourceEffects"
      to: "calculatePersonalityAlignment"
      via: "alignment multipliers"
      pattern: "alignment.*Multiplier"
---

<objective>
Integrate need restoration and personality-aligned resource costs into ActivityStore.

Purpose: Activities restore needs gradually during execution and consume resources scaled by difficulty and personality alignment. Struggling patients get reduced costs as an escape valve.

Output: Extended ActivityStore.applyResourceEffects that handles v1.1 needs system integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-activity-need-integration/10-CONTEXT.md
@.planning/phases/10-activity-need-integration/10-RESEARCH.md
@.planning/phases/10-activity-need-integration/10-02-SUMMARY.md

@src/stores/ActivityStore.ts
@src/entities/Activity.ts
@src/entities/Character.ts
@src/utils/personalityFit.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend applyResourceEffects for need restoration</name>
  <files>src/stores/ActivityStore.ts</files>
  <action>
Import calculatePersonalityAlignment from '../utils/personalityFit'.
Import NeedKey from '../entities/types'.

Extend the existing applyResourceEffects method to handle v1.1 needs system:

After the existing resource effects loop, add need restoration:

```typescript
// v1.1 Need restoration (if needs system enabled)
if (character.needs && activity.needEffects) {
  const alignment = calculatePersonalityAlignment(
    activity.tags,
    character.personality
  );

  for (const [needKey, baseRestore] of Object.entries(activity.needEffects)) {
    // Apply personality gain multiplier
    let restore = baseRestore * alignment.gainMultiplier * speedMultiplier;

    // Apply mastery bonus (same pattern as resource restore)
    restore *= 1 + activity.masteryBonus * 0.5;

    // Update need (clamped to 0-100)
    const key = needKey as NeedKey;
    character.needs[key] = Math.max(0, Math.min(100, character.needs[key] + restore));
  }
}
```

Key points:
- Only applies if character.needs exists (v1.1 enabled)
- Only applies if activity.needEffects exists
- Uses personality gainMultiplier for aligned activities
- Uses existing masteryBonus pattern for consistency
- Restoration is gradual (per-tick), retained on interruption (no state restoration)
- No diminishing returns - same restoration each time (CONTEXT.md requirement)
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Need restoration code exists: `grep -l "needEffects" src/stores/ActivityStore.ts`
  </verify>
  <done>ActivityStore.applyResourceEffects restores needs per-tick with personality alignment multiplier</done>
</task>

<task type="auto">
  <name>Task 2: Integrate personality-aligned resource costs</name>
  <files>src/stores/ActivityStore.ts</files>
  <action>
Modify applyResourceEffects to apply personality alignment to resource drain.

Current code applies mastery reduction to drains. Extend to also apply personality alignment:

```typescript
private applyResourceEffects(speedMultiplier: number): void {
  const activity = this.currentActivity;
  const character = this.root.characterStore.character;
  if (!activity || !character) return;

  // Calculate alignment once for this tick
  const alignment = calculatePersonalityAlignment(
    activity.tags,
    character.personality
  );

  // Calculate escape valve multiplier (struggling patient gets 50% cost reduction)
  const escapeValve = this.calculateEscapeValve(character);

  for (const [key, baseEffect] of Object.entries(activity.resourceEffects)) {
    const resourceKey = key as ResourceKey;
    let effect = baseEffect * speedMultiplier;

    // Mastery reduces drain, modestly increases restore
    if (effect < 0) {
      // DRAIN: apply mastery reduction, alignment cost multiplier, escape valve
      effect *= 1 - activity.masteryDrainReduction;
      effect *= alignment.costMultiplier;  // aligned = lower costs
      effect *= escapeValve;               // struggling = lower costs
    } else {
      // RESTORE: apply mastery bonus, alignment gain multiplier
      effect *= 1 + activity.masteryBonus * 0.5;
      effect *= alignment.gainMultiplier;  // aligned = higher gains
    }

    // Apply to character resources (clamp handled in updateResources)
    const newValue = Math.max(
      0,
      Math.min(100, character.resources[resourceKey] + effect)
    );
    character.resources[resourceKey] = newValue;
  }

  // v1.1 Need restoration (from Task 1) - also use alignment
  // ... (need restoration code from Task 1)
}
```

Add escape valve helper method:

```typescript
/**
 * Calculate escape valve multiplier for struggling patients.
 * When any physiological need is below 20%, reduce activity costs by 50%.
 * This prevents total paralysis when patient is in crisis.
 */
private calculateEscapeValve(character: Character): number {
  if (!character.needs) return 1.0; // v1.0 mode, no escape valve

  const physiologicalNeeds = ['hunger', 'energy', 'hygiene', 'bladder'] as const;
  const isStrugging = physiologicalNeeds.some(
    need => character.needs![need] < 20
  );

  return isStrugging ? 0.5 : 1.0;
}
```

Important CONTEXT.md rules implemented:
- Difficulty-to-cost is already handled by Activity.getResourceCosts
- But per-tick drain comes from resourceEffects, so alignment applies here
- Escape valve: 50% cost reduction when ANY physiological need < 20%
- Basic need activities are already free (no startRequirements check needed)
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Escape valve exists: `grep -l "calculateEscapeValve" src/stores/ActivityStore.ts`
3. Alignment applied: `grep -l "costMultiplier\|gainMultiplier" src/stores/ActivityStore.ts`
  </verify>
  <done>Resource effects apply personality alignment modifiers and escape valve for struggling patients</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Need restoration applies per-tick with alignment.gainMultiplier
3. Resource drain applies alignment.costMultiplier
4. Escape valve reduces costs 50% when physiological needs < 20%
5. Mastery bonuses still apply correctly
</verification>

<success_criteria>
- Activities restore needs gradually during execution
- Interruption retains partial restoration (no state rollback)
- Personality alignment affects both resource drain and need restoration
- Struggling patients (any physiological need < 20%) get 50% cost reduction
- All existing mastery mechanics still function
</success_criteria>

<output>
After completion, create `.planning/phases/10-activity-need-integration/10-03-SUMMARY.md`
</output>
