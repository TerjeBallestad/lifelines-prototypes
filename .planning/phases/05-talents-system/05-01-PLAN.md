---
phase: 05-talents-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/entities/types.ts
  - src/entities/Talent.ts
autonomous: true

must_haves:
  truths:
    - "Talent type definitions exist for rarity, modifiers, and talent data"
    - "Talent class is observable and mirrors existing entity patterns"
    - "Rarity weight calculation produces correct probabilities"
  artifacts:
    - path: "src/entities/types.ts"
      provides: "TalentRarity, ModifierType, ModifierEffect, TalentData types"
      contains: "TalentRarity"
    - path: "src/entities/Talent.ts"
      provides: "Talent entity class"
      exports: ["Talent"]
      min_lines: 40
  key_links:
    - from: "src/entities/Talent.ts"
      to: "src/entities/types.ts"
      via: "import"
      pattern: "import.*TalentData.*from.*types"
---

<objective>
Create the Talent entity class and type definitions that support the roguelike talent system.

Purpose: Establish the data model for talents with rarity tiers and modifier effects, following the existing Character/Skill/Activity entity pattern.
Output: Talent.ts entity class and extended types.ts with talent-related type definitions.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-talents-system/05-CONTEXT.md
@.planning/phases/05-talents-system/05-RESEARCH.md

@src/entities/types.ts
@src/entities/Skill.ts
@src/entities/Activity.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add talent type definitions to types.ts</name>
  <files>src/entities/types.ts</files>
  <action>
Add the following type definitions after the existing Activity types section:

```typescript
// ============================================================================
// Talent System Types
// ============================================================================

// Talent rarity tiers (affects spawn weight)
export type TalentRarity = 'common' | 'rare' | 'epic';

// Modifier effect types
export type ModifierType = 'flat' | 'percentage' | 'conditional';

// Modifier effect definition
export interface ModifierEffect {
  type: ModifierType;
  target: 'capacity' | 'resource' | 'skill' | 'activity';
  targetKey: string; // capacity name, resource name, etc.
  value: number; // +10 flat, or 0.15 for 15%
  condition?: {
    type: 'resource_threshold' | 'activity_type' | 'domain';
    check: string; // e.g., "energy < 30", "domain === 'physical'"
  };
  description: string; // For UI display
}

// Data required to construct a Talent
export interface TalentData {
  id: string;
  name: string;
  description: string;
  rarity: TalentRarity;
  domain: SkillDomain | null; // null = universal talent
  effects: ModifierEffect[];
}
```

Note: Place after ActivityData interface, before any closing comments.
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit`</verify>
  <done>TalentRarity, ModifierType, ModifierEffect, and TalentData types exported from types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create Talent entity class</name>
  <files>src/entities/Talent.ts</files>
  <action>
Create new file following the Skill.ts/Activity.ts pattern:

```typescript
import { makeAutoObservable } from 'mobx';
import type { TalentData, TalentRarity, SkillDomain, ModifierEffect } from './types';

/**
 * Talent entity - represents a roguelike talent/modifier.
 * Uses class-based pattern to mirror Character/Skill/Activity structure.
 * All properties are observable, all methods are actions.
 */
export class Talent {
  readonly id: string;
  readonly name: string;
  readonly description: string;
  readonly rarity: TalentRarity;
  readonly domain: SkillDomain | null;
  readonly effects: ModifierEffect[];

  constructor(data: TalentData) {
    this.id = data.id;
    this.name = data.name;
    this.description = data.description;
    this.rarity = data.rarity;
    this.domain = data.domain;
    this.effects = data.effects;

    makeAutoObservable(this);
  }

  /**
   * Computed: Rarity weight for selection probability.
   * Common = 70, Rare = 25, Epic = 5 (totals 100 for easy % calculation)
   */
  get rarityWeight(): number {
    const weights: Record<TalentRarity, number> = {
      common: 70,
      rare: 25,
      epic: 5,
    };
    return weights[this.rarity];
  }

  /**
   * Computed: Whether this talent is domain-specific or universal.
   */
  get isUniversal(): boolean {
    return this.domain === null;
  }

  /**
   * Computed: CSS color class for rarity display.
   */
  get rarityColorClass(): string {
    const colors: Record<TalentRarity, string> = {
      common: 'text-base-content',
      rare: 'text-info',
      epic: 'text-secondary',
    };
    return colors[this.rarity];
  }
}
```
  </action>
  <verify>TypeScript compilation passes: `npx tsc --noEmit`</verify>
  <done>Talent class exists with id, name, description, rarity, domain, effects, and computed rarityWeight/isUniversal/rarityColorClass</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` completes without errors
2. types.ts contains TalentRarity, ModifierType, ModifierEffect, TalentData exports
3. Talent.ts exports Talent class with makeAutoObservable pattern
</verification>

<success_criteria>
- Talent type definitions match RESEARCH.md specifications
- Talent entity mirrors existing Skill/Activity patterns
- Rarity weights: common=70, rare=25, epic=5
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/05-talents-system/05-01-SUMMARY.md`
</output>
