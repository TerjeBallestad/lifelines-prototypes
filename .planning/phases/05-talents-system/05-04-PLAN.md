---
phase: 05-talents-system
plan: 04
type: execute
wave: 4
depends_on: ["05-03"]
files_modified:
  - src/components/TalentsPanel.tsx
  - src/entities/Character.ts
  - src/stores/CharacterStore.ts
  - src/App.tsx
autonomous: false

must_haves:
  truths:
    - "TalentsPanel shows all selected talents"
    - "Talent effects visibly modify character stats"
    - "Stat breakdown shows talent contributions to resources and capacities"
    - "Player can observe talent effects in gameplay"
  artifacts:
    - path: "src/components/TalentsPanel.tsx"
      provides: "Selected talents display with stat breakdown section"
      exports: ["TalentsPanel"]
      min_lines: 80
    - path: "src/entities/Character.ts"
      provides: "Talent modifier integration with effective capacity getters"
      contains: "effectiveCapacities"
  key_links:
    - from: "src/entities/Character.ts"
      to: "src/stores/TalentStore.ts"
      via: "root.talentStore access"
      pattern: "root.talentStore"
    - from: "src/components/TalentsPanel.tsx"
      to: "src/stores/TalentStore.ts"
      via: "useTalentStore hook"
      pattern: "useTalentStore"
---

<objective>
Create TalentsPanel to display selected talents with stat breakdown, and integrate talent effects into character stats including both resource modifiers and capacity bonuses.

Purpose: Make talents visibly affect gameplay by modifying resource drain rates and capacity values, and show stat breakdowns so players understand talent impact.
Output: TalentsPanel component with stat breakdown, Character.ts extended with both resource and capacity talent modifiers, human verification of effects.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-talents-system/05-CONTEXT.md
@.planning/phases/05-talents-system/05-RESEARCH.md

@src/entities/Character.ts
@src/entities/types.ts
@src/stores/TalentStore.ts
@src/stores/RootStore.ts
@src/stores/CharacterStore.ts
@src/App.tsx
@src/components/TalentCard.tsx
@src/components/CharacterPanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate talent modifiers into Character (resources AND capacities)</name>
  <files>src/entities/Character.ts, src/stores/CharacterStore.ts</files>
  <action>
Extend Character with RootStore access and computed getters for both resource modifiers and effective capacities.

1. Add RootStore reference to Character constructor:

```typescript
import { type RootStore } from '../stores/RootStore';

// Add private root property
private root?: RootStore;

// Update constructor (add optional root parameter)
constructor(data: CharacterData, root?: RootStore) {
  this.id = data.id;
  this.name = data.name;
  this.personality = data.personality;
  this.capacities = data.capacities;
  this.resources = data.resources;
  this.root = root;

  makeAutoObservable(this);
}

// Add setter for root (called by CharacterStore after construction)
setRootStore(root: RootStore): void {
  this.root = root;
}
```

2. Extend activeModifiers getter to include talent effects for resources:

At the end of the activeModifiers getter, before `return modifiers;`, add:

```typescript
// Add talent modifiers for resources
if (this.root?.talentStore) {
  const talents = this.root.talentStore.selectedTalentsArray;
  for (const talent of talents) {
    for (const effect of talent.effects) {
      // Only apply resource modifiers here (percentage type for drain/recovery)
      if (effect.target === 'resource' && effect.type === 'percentage') {
        modifiers.push({
          resourceKey: effect.targetKey as ResourceKey,
          source: talent.name,
          drainModifier: effect.value, // positive = faster drain, negative = slower
          recoveryModifier: 0,
        });
      }
    }
  }
}
```

3. Add computed getter for effective capacities (base + talent flat bonuses):

```typescript
import type { Capacities, CapacityKey } from './types';

/**
 * Computed: Effective capacities including talent flat bonuses.
 * Returns a new Capacities object with talent modifiers applied.
 */
get effectiveCapacities(): Capacities {
  // Start with base capacities
  const effective: Capacities = { ...this.capacities };

  // Apply talent capacity bonuses
  if (this.root?.talentStore) {
    const talents = this.root.talentStore.selectedTalentsArray;
    for (const talent of talents) {
      for (const effect of talent.effects) {
        if (effect.target === 'capacity' && effect.type === 'flat') {
          const key = effect.targetKey as CapacityKey;
          if (key in effective) {
            effective[key] = (effective[key] ?? 0) + effect.value;
          }
        }
      }
    }
  }

  return effective;
}

/**
 * Computed: Breakdown of capacity modifiers by talent.
 * Returns map of capacityKey -> array of { source, value } for UI display.
 */
get capacityModifierBreakdown(): Map<CapacityKey, Array<{ source: string; value: number }>> {
  const breakdown = new Map<CapacityKey, Array<{ source: string; value: number }>>();

  if (this.root?.talentStore) {
    const talents = this.root.talentStore.selectedTalentsArray;
    for (const talent of talents) {
      for (const effect of talent.effects) {
        if (effect.target === 'capacity' && effect.type === 'flat') {
          const key = effect.targetKey as CapacityKey;
          if (!breakdown.has(key)) {
            breakdown.set(key, []);
          }
          breakdown.get(key)!.push({ source: talent.name, value: effect.value });
        }
      }
    }
  }

  return breakdown;
}

/**
 * Computed: Breakdown of resource modifiers by talent.
 * Returns map of resourceKey -> array of { source, value, type } for UI display.
 */
get resourceModifierBreakdown(): Map<ResourceKey, Array<{ source: string; value: number; type: 'drain' | 'recovery' }>> {
  const breakdown = new Map<ResourceKey, Array<{ source: string; value: number; type: 'drain' | 'recovery' }>>();

  if (this.root?.talentStore) {
    const talents = this.root.talentStore.selectedTalentsArray;
    for (const talent of talents) {
      for (const effect of talent.effects) {
        if (effect.target === 'resource' && effect.type === 'percentage') {
          const key = effect.targetKey as ResourceKey;
          if (!breakdown.has(key)) {
            breakdown.set(key, []);
          }
          breakdown.get(key)!.push({
            source: talent.name,
            value: effect.value,
            type: effect.value > 0 ? 'drain' : 'recovery',
          });
        }
      }
    }
  }

  return breakdown;
}
```

4. Update CharacterStore to pass root and call setRootStore:

In CharacterStore.createCharacter, after creating the character:
```typescript
// After: this.character = new Character(characterData);
this.character?.setRootStore(this.root);
```
  </action>
  <verify>`npx tsc --noEmit` passes; `npm run dev` starts without errors</verify>
  <done>Character has effectiveCapacities getter, capacityModifierBreakdown, resourceModifierBreakdown, and activeModifiers includes talent resource effects</done>
</task>

<task type="auto">
  <name>Task 2: Create TalentsPanel component with stat breakdown</name>
  <files>src/components/TalentsPanel.tsx</files>
  <action>
Create panel showing selected talents AND their stat impact following CharacterPanel patterns:

```typescript
import { observer } from 'mobx-react-lite';
import { useTalentStore, useCharacterStore } from '../stores/RootStore';
import { TalentCard } from './TalentCard';

/**
 * Panel displaying all selected talents with their effects.
 * Shows in main content area alongside skills and activities.
 * Includes stat breakdown section showing talent contributions.
 */
export const TalentsPanel = observer(function TalentsPanel() {
  const talentStore = useTalentStore();
  const characterStore = useCharacterStore();
  const character = characterStore.character;
  const selectedTalents = talentStore.selectedTalentsArray;

  // Get modifier breakdowns from character
  const capacityBreakdown = character?.capacityModifierBreakdown;
  const resourceBreakdown = character?.resourceModifierBreakdown;

  // Check if there are any active modifiers to show
  const hasCapacityMods = capacityBreakdown && capacityBreakdown.size > 0;
  const hasResourceMods = resourceBreakdown && resourceBreakdown.size > 0;
  const hasAnyMods = hasCapacityMods || hasResourceMods;

  return (
    <div className="card bg-base-200 shadow-lg">
      <div className="card-body">
        {/* Header with count */}
        <div className="flex items-center justify-between">
          <h2 className="card-title">Talents</h2>
          <span className="badge badge-neutral">
            {selectedTalents.length} selected
          </span>
        </div>

        {/* Empty state */}
        {selectedTalents.length === 0 && (
          <div className="text-center py-8 opacity-60">
            <p>No talents selected yet.</p>
            <p className="text-sm mt-2">
              Earn 500 domain XP to unlock talent picks!
            </p>
          </div>
        )}

        {/* Selected talents list */}
        {selectedTalents.length > 0 && (
          <div className="space-y-3 mt-2">
            {selectedTalents.map((talent) => (
              <TalentCard key={talent.id} talent={talent} compact />
            ))}
          </div>
        )}

        {/* Stat Breakdown Section */}
        {hasAnyMods && (
          <div className="mt-4 pt-4 border-t border-base-300">
            <h3 className="text-sm font-semibold opacity-80 mb-2">
              Talent Effects
            </h3>

            {/* Capacity modifiers */}
            {hasCapacityMods && (
              <div className="mb-3">
                <div className="text-xs font-medium opacity-60 uppercase mb-1">
                  Capacities
                </div>
                <div className="space-y-1">
                  {Array.from(capacityBreakdown!.entries()).map(([key, mods]) => (
                    <div key={key} className="flex justify-between text-sm">
                      <span className="capitalize">
                        {key.replace(/([A-Z])/g, ' $1').trim()}
                      </span>
                      <span className="text-success">
                        {mods.map((m, i) => (
                          <span key={i} title={m.source}>
                            {i > 0 ? ', ' : ''}
                            +{m.value}
                          </span>
                        ))}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Resource modifiers */}
            {hasResourceMods && (
              <div>
                <div className="text-xs font-medium opacity-60 uppercase mb-1">
                  Resource Rates
                </div>
                <div className="space-y-1">
                  {Array.from(resourceBreakdown!.entries()).map(([key, mods]) => (
                    <div key={key} className="flex justify-between text-sm">
                      <span className="capitalize">
                        {key.replace(/([A-Z])/g, ' $1').trim()}
                      </span>
                      <span>
                        {mods.map((m, i) => (
                          <span
                            key={i}
                            title={m.source}
                            className={m.value < 0 ? 'text-success' : 'text-error'}
                          >
                            {i > 0 ? ', ' : ''}
                            {m.value > 0 ? '+' : ''}{Math.round(m.value * 100)}%
                          </span>
                        ))}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {/* Pending picks indicator */}
        {talentStore.pendingPicks > 0 && (
          <div className="alert alert-warning mt-4">
            <span>
              {talentStore.pendingPicks} talent pick{talentStore.pendingPicks > 1 ? 's' : ''} available!
            </span>
            <button
              className="btn btn-sm btn-primary"
              onClick={() => talentStore.generateOffer()}
            >
              Choose
            </button>
          </div>
        )}

        {/* Dev: Force offer button (for testing) */}
        {import.meta.env.DEV && selectedTalents.length < talentStore.talentsArray.length - 2 && (
          <details className="mt-4">
            <summary className="cursor-pointer text-sm opacity-60">Dev Tools</summary>
            <button
              className="btn btn-xs btn-outline mt-2"
              onClick={() => talentStore.forceOffer()}
            >
              Force Talent Offer
            </button>
          </details>
        )}
      </div>
    </div>
  );
});
```
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>TalentsPanel displays selected talents, shows stat breakdown with capacity bonuses and resource rate modifiers</done>
</task>

<task type="auto">
  <name>Task 3: Add TalentsPanel to App.tsx</name>
  <files>src/App.tsx</files>
  <action>
Add TalentsPanel to main content area:

1. Add import:
```typescript
import { TalentsPanel } from './components/TalentsPanel';
```

2. Add component after ActivityPanel in main content:
```typescript
<div className="mt-6">
  <ActivityPanel />
</div>
<div className="mt-6">
  <TalentsPanel />
</div>
```

The TalentsPanel will show below ActivityPanel in the main content area.
  </action>
  <verify>`npm run dev` shows TalentsPanel in UI</verify>
  <done>TalentsPanel visible in main content area below ActivityPanel</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete talent system with:
- Pick-1-of-3 selection modal
- Selected talents display in TalentsPanel
- Talent effects modify resource drain rates
- Talent effects modify capacity values (effectiveCapacities)
- Stat breakdown section shows all talent contributions
  </what-built>
  <how-to-verify>
1. Open browser at http://localhost:5173
2. In TalentsPanel, expand "Dev Tools" and click "Force Talent Offer"
3. Verify modal appears with 3 talents showing rarity (colors/badges)
4. Select a capacity-boosting talent (e.g., "Hyperfocus" for +15 convergent thinking)
5. Verify modal closes and talent appears in TalentsPanel
6. Verify "Talent Effects" section appears showing the capacity bonus (e.g., "Convergent Thinking: +15")
7. Select another talent with resource effect (e.g., "Iron Will" for stress reduction)
8. Verify "Resource Rates" section shows the modifier (e.g., "Stress: -15%")
9. Start simulation and observe resource drain rates match modifiers

Alternative verification:
- Open browser console
- Run: `rootStore.talentStore.forceOffer()`
- Select talent in modal
- Run: `rootStore.characterStore.character.effectiveCapacities` to see capacity bonuses applied
- Run: `rootStore.characterStore.character.capacityModifierBreakdown` to see breakdown
- Run: `rootStore.characterStore.character.activeModifiers` to see resource modifiers included
  </how-to-verify>
  <resume-signal>Type "approved" if talents work correctly with stat breakdown, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` completes without errors
2. `npm run dev` starts without errors
3. TalentsPanel visible in UI
4. Forcing talent offer shows modal
5. Selecting talent adds to TalentsPanel
6. Character.effectiveCapacities includes talent flat bonuses
7. Character.activeModifiers includes talent resource effects
8. TalentsPanel shows "Talent Effects" breakdown section
9. Capacity bonuses visible in breakdown
10. Resource rate modifiers visible in breakdown
</verification>

<success_criteria>
- TalentsPanel shows selected talents with compact cards
- Stat breakdown section shows capacity bonuses (e.g., "Convergent Thinking: +15")
- Stat breakdown section shows resource rate modifiers (e.g., "Stress: -15%")
- effectiveCapacities computed getter returns capacities with talent bonuses
- Pending picks indicator visible when picks available
- Dev button forces talent offer for testing
- Human verification confirms visible talent effects in both stats and gameplay
</success_criteria>

<output>
After completion, create `.planning/phases/05-talents-system/05-04-SUMMARY.md`
</output>
