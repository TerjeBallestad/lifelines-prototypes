---
phase: 05-talents-system
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/utils/weightedRandom.ts
  - src/data/talents.ts
  - src/stores/TalentStore.ts
  - src/stores/RootStore.ts
  - src/stores/SkillStore.ts
autonomous: true

must_haves:
  truths:
    - "Weighted random sampling produces no duplicates in 3-talent offers"
    - "9-12 talents exist in the pool with rarity distribution"
    - "TalentStore tracks pending picks and current offer"
    - "Domain XP threshold (500) triggers talent picks"
  artifacts:
    - path: "src/utils/weightedRandom.ts"
      provides: "Weighted sampling without replacement"
      exports: ["weightedSampleWithoutReplacement"]
    - path: "src/data/talents.ts"
      provides: "Talent pool data (9-12 talents)"
      exports: ["TALENTS"]
    - path: "src/stores/TalentStore.ts"
      provides: "Talent state management"
      exports: ["TalentStore"]
    - path: "src/stores/RootStore.ts"
      provides: "TalentStore integration"
      contains: "talentStore"
  key_links:
    - from: "src/stores/TalentStore.ts"
      to: "src/entities/Talent.ts"
      via: "import"
      pattern: "import.*Talent.*from"
    - from: "src/stores/SkillStore.ts"
      to: "src/stores/TalentStore.ts"
      via: "checkForTalentPick call"
      pattern: "talentStore.checkForTalentPick"
---

<objective>
Create the TalentStore with pool management, weighted random selection, and XP-triggered talent picks.

Purpose: Enable roguelike talent selection with weighted random 1-of-3 offers triggered by domain XP milestones.
Output: TalentStore integrated into RootStore, talent seed data, weighted random utility.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-talents-system/05-CONTEXT.md
@.planning/phases/05-talents-system/05-RESEARCH.md

@src/entities/Talent.ts
@src/entities/types.ts
@src/stores/SkillStore.ts
@src/stores/RootStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create weighted random sampling utility</name>
  <files>src/utils/weightedRandom.ts</files>
  <action>
Create new file implementing cumulative weight algorithm:

```typescript
/**
 * Weighted random sampling without replacement.
 * Uses cumulative weight algorithm for unbiased selection.
 */

/**
 * Sample N indices from weights array without replacement.
 * Higher weight = higher probability of selection.
 *
 * @param weights - Array of positive weights
 * @param sampleSize - Number of items to sample (N)
 * @returns Array of N unique indices into weights array
 * @throws Error if sampleSize > weights.length
 */
export function weightedSampleWithoutReplacement(
  weights: number[],
  sampleSize: number
): number[] {
  if (sampleSize > weights.length) {
    throw new Error(`Sample size (${sampleSize}) exceeds population (${weights.length})`);
  }

  const indices: number[] = [];
  const availableWeights = [...weights];
  const availableIndices = weights.map((_, i) => i);

  for (let i = 0; i < sampleSize; i++) {
    // Build cumulative weights
    const cumulative: number[] = [];
    let sum = 0;
    for (const w of availableWeights) {
      sum += w;
      cumulative.push(sum);
    }

    // Random selection using cumulative distribution
    const rand = Math.random() * sum;
    const selectedIdx = cumulative.findIndex((c) => c >= rand);

    // Record selection and remove from pool
    indices.push(availableIndices[selectedIdx]);
    availableWeights.splice(selectedIdx, 1);
    availableIndices.splice(selectedIdx, 1);
  }

  return indices;
}
```
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>weightedSampleWithoutReplacement function exported from weightedRandom.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create talent seed data</name>
  <files>src/data/talents.ts</files>
  <action>
Create new file with 10 talents following CONTEXT.md guidelines (fun effects, ~30% tradeoffs, some overpowered):

```typescript
import type { TalentData } from '../entities/types';

/**
 * Talent pool for roguelike selection.
 * Distribution: ~5 common, ~3 rare, ~2 epic
 * ~30% have tradeoffs (upside AND downside)
 */
export const TALENTS: TalentData[] = [
  // === COMMON (70% spawn rate) ===
  {
    id: 'quick_learner',
    name: 'Quick Learner',
    description: '+20% mastery XP gain from activities',
    rarity: 'common',
    domain: null,
    effects: [
      {
        type: 'percentage',
        target: 'activity',
        targetKey: 'masteryXP',
        value: 0.20,
        description: 'Mastery XP +20%',
      },
    ],
  },
  {
    id: 'iron_will',
    name: 'Iron Will',
    description: 'Stress drains 15% slower',
    rarity: 'common',
    domain: 'physical',
    effects: [
      {
        type: 'percentage',
        target: 'resource',
        targetKey: 'stress',
        value: -0.15,
        description: 'Stress builds 15% slower',
      },
    ],
  },
  {
    id: 'social_butterfly',
    name: 'Social Butterfly',
    description: 'Social battery drains 15% slower',
    rarity: 'common',
    domain: 'social',
    effects: [
      {
        type: 'percentage',
        target: 'resource',
        targetKey: 'socialBattery',
        value: -0.15,
        description: 'Social battery drains 15% slower',
      },
    ],
  },
  {
    id: 'early_bird',
    name: 'Early Bird',
    description: 'Energy drains 10% slower, but focus drains 10% faster',
    rarity: 'common',
    domain: null,
    effects: [
      {
        type: 'percentage',
        target: 'resource',
        targetKey: 'energy',
        value: -0.10,
        description: 'Energy drains 10% slower',
      },
      {
        type: 'percentage',
        target: 'resource',
        targetKey: 'focus',
        value: 0.10,
        description: 'Focus drains 10% faster',
      },
    ],
  },
  {
    id: 'optimist',
    name: 'Optimist',
    description: 'Mood recovers 20% faster',
    rarity: 'common',
    domain: null,
    effects: [
      {
        type: 'percentage',
        target: 'resource',
        targetKey: 'mood',
        value: 0.20,
        description: 'Mood recovers 20% faster',
      },
    ],
  },

  // === RARE (25% spawn rate) ===
  {
    id: 'hyperfocus',
    name: 'Hyperfocus',
    description: '+30% convergent thinking, but social battery drains 20% faster',
    rarity: 'rare',
    domain: 'analytical',
    effects: [
      {
        type: 'flat',
        target: 'capacity',
        targetKey: 'convergentThinking',
        value: 15,
        description: 'Convergent Thinking +15',
      },
      {
        type: 'percentage',
        target: 'resource',
        targetKey: 'socialBattery',
        value: 0.20,
        description: 'Social battery drains 20% faster',
      },
    ],
  },
  {
    id: 'creative_spark',
    name: 'Creative Spark',
    description: '+15 divergent thinking, +10% domain XP for creative activities',
    rarity: 'rare',
    domain: 'creative',
    effects: [
      {
        type: 'flat',
        target: 'capacity',
        targetKey: 'divergentThinking',
        value: 15,
        description: 'Divergent Thinking +15',
      },
      {
        type: 'conditional',
        target: 'activity',
        targetKey: 'domainXP',
        value: 0.10,
        condition: {
          type: 'domain',
          check: 'creative',
        },
        description: '+10% domain XP for creative activities',
      },
    ],
  },
  {
    id: 'methodical',
    name: 'Methodical',
    description: '+20 working memory, activities take 10% longer',
    rarity: 'rare',
    domain: 'organisational',
    effects: [
      {
        type: 'flat',
        target: 'capacity',
        targetKey: 'workingMemory',
        value: 20,
        description: 'Working Memory +20',
      },
      {
        type: 'percentage',
        target: 'activity',
        targetKey: 'duration',
        value: 0.10,
        description: 'Activities take 10% longer',
      },
    ],
  },

  // === EPIC (5% spawn rate) - intentionally powerful ===
  {
    id: 'second_wind',
    name: 'Second Wind',
    description: 'When energy drops below 20, gain +30 energy (once per 50 ticks)',
    rarity: 'epic',
    domain: 'physical',
    effects: [
      {
        type: 'conditional',
        target: 'resource',
        targetKey: 'energy',
        value: 30,
        condition: {
          type: 'resource_threshold',
          check: 'energy < 20',
        },
        description: 'Restore 30 energy when below 20 (cooldown: 50 ticks)',
      },
    ],
  },
  {
    id: 'flow_state',
    name: 'Flow State',
    description: 'All capacities +10, overskudd drains 20% faster (chaotic power)',
    rarity: 'epic',
    domain: null,
    effects: [
      {
        type: 'flat',
        target: 'capacity',
        targetKey: 'divergentThinking',
        value: 10,
        description: 'Divergent Thinking +10',
      },
      {
        type: 'flat',
        target: 'capacity',
        targetKey: 'convergentThinking',
        value: 10,
        description: 'Convergent Thinking +10',
      },
      {
        type: 'flat',
        target: 'capacity',
        targetKey: 'workingMemory',
        value: 10,
        description: 'Working Memory +10',
      },
      {
        type: 'flat',
        target: 'capacity',
        targetKey: 'attentionSpan',
        value: 10,
        description: 'Attention Span +10',
      },
      {
        type: 'flat',
        target: 'capacity',
        targetKey: 'processingSpeed',
        value: 10,
        description: 'Processing Speed +10',
      },
      {
        type: 'flat',
        target: 'capacity',
        targetKey: 'emotionalRegulation',
        value: 10,
        description: 'Emotional Regulation +10',
      },
      {
        type: 'percentage',
        target: 'resource',
        targetKey: 'overskudd',
        value: 0.20,
        description: 'Overskudd drains 20% faster',
      },
    ],
  },
];
```
  </action>
  <verify>`npx tsc --noEmit` passes</verify>
  <done>10 talents exported from talents.ts with proper rarity distribution</done>
</task>

<task type="auto">
  <name>Task 3: Create TalentStore and integrate into RootStore</name>
  <files>src/stores/TalentStore.ts, src/stores/RootStore.ts, src/stores/SkillStore.ts</files>
  <action>
Create TalentStore following SkillStore pattern:

```typescript
// src/stores/TalentStore.ts
import { makeAutoObservable, observable } from 'mobx';
import { Talent } from '../entities/Talent';
import type { TalentData, SkillDomain } from '../entities/types';
import { TALENTS } from '../data/talents';
import { type RootStore } from './RootStore';
import { weightedSampleWithoutReplacement } from '../utils/weightedRandom';

/** XP threshold per domain to earn a talent pick */
const PICK_THRESHOLD = 500;

/** Maximum pending picks that can queue */
const MAX_PENDING_PICKS = 3;

export class TalentStore {
  talentPool = observable.map<string, Talent>();
  selectedTalents = observable.map<string, Talent>();
  pendingPicks: number = 0;
  currentOffer: Talent[] | null = null;

  /** Track XP thresholds crossed per domain to avoid double-triggering */
  private pickThresholdsCrossed = observable.map<SkillDomain, number>();

  private readonly root: RootStore;

  constructor(root: RootStore) {
    this.root = root;
    makeAutoObservable(this);

    // Seed talent pool from data
    this.seedTalents(TALENTS);
  }

  get talentsArray(): Talent[] {
    return Array.from(this.talentPool.values());
  }

  get selectedTalentsArray(): Talent[] {
    return Array.from(this.selectedTalents.values());
  }

  get availableTalents(): Talent[] {
    return this.talentsArray.filter((t) => !this.selectedTalents.has(t.id));
  }

  /** Check if player has earned a talent pick based on domain XP */
  checkForTalentPick(domain: SkillDomain, newTotalXP: number): void {
    const prevThreshold = this.pickThresholdsCrossed.get(domain) ?? 0;
    const newThreshold = Math.floor(newTotalXP / PICK_THRESHOLD);

    if (newThreshold > prevThreshold) {
      this.pickThresholdsCrossed.set(domain, newThreshold);
      this.addPendingPick();
    }
  }

  private addPendingPick(): void {
    if (this.pendingPicks < MAX_PENDING_PICKS) {
      this.pendingPicks++;

      // Auto-generate offer if none active
      if (!this.currentOffer) {
        this.generateOffer();
      }
    }
  }

  /** Generate weighted random 1-of-3 offer (no duplicates) */
  generateOffer(): void {
    const available = this.availableTalents;

    if (available.length < 3) {
      console.warn('[TalentStore] Not enough talents for offer');
      return;
    }

    const weights = available.map((t) => t.rarityWeight);
    const indices = weightedSampleWithoutReplacement(weights, 3);
    this.currentOffer = indices.map((i) => available[i]);
  }

  /** Select a talent from current offer */
  selectTalent(talentId: string): boolean {
    if (!this.currentOffer) return false;

    const talent = this.currentOffer.find((t) => t.id === talentId);
    if (!talent) return false;

    // Add to selected
    this.selectedTalents.set(talent.id, talent);

    // Consume pending pick
    this.pendingPicks--;
    this.currentOffer = null;

    // Generate next offer if picks remain
    if (this.pendingPicks > 0) {
      this.generateOffer();
    }

    return true;
  }

  /** Force open talent selection (for testing) */
  forceOffer(): void {
    if (this.availableTalents.length >= 3) {
      this.pendingPicks = Math.max(1, this.pendingPicks);
      this.generateOffer();
    }
  }

  private seedTalents(talentDataList: TalentData[]): void {
    for (const data of talentDataList) {
      const talent = new Talent(data);
      this.talentPool.set(data.id, talent);
    }
  }

  get rootStore(): RootStore {
    return this.root;
  }
}
```

Update RootStore to add TalentStore:

```typescript
// Add import at top
import { TalentStore } from './TalentStore';

// Add to class
export class RootStore {
  characterStore: CharacterStore;
  simulationStore: SimulationStore;
  skillStore: SkillStore;
  activityStore: ActivityStore;
  talentStore: TalentStore;  // ADD

  constructor() {
    this.characterStore = new CharacterStore(this);
    this.simulationStore = new SimulationStore(this);
    this.skillStore = new SkillStore(this);
    this.activityStore = new ActivityStore(this);
    this.talentStore = new TalentStore(this);  // ADD
  }
}

// Add convenience hook at bottom
export function useTalentStore() {
  return useRootStore().talentStore;
}
```

Update SkillStore.addDomainXP to trigger talent check:

```typescript
// In addDomainXP method, add talent check after updating XP
addDomainXP(domain: SkillDomain, amount: number): void {
  const current = this.domainXP.get(domain) ?? 0;
  const newTotal = current + amount;
  this.domainXP.set(domain, newTotal);

  // Check for talent pick threshold
  this.root.talentStore.checkForTalentPick(domain, newTotal);
}
```
  </action>
  <verify>`npx tsc --noEmit` passes; `npm run dev` starts without errors</verify>
  <done>TalentStore created, integrated into RootStore, SkillStore triggers talent checks on XP gain</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` completes without errors
2. `npm run dev` starts without errors
3. TalentStore has talentPool with 10 talents
4. useTalentStore hook is available
5. SkillStore.addDomainXP triggers checkForTalentPick
</verification>

<success_criteria>
- 10 talents in pool with correct rarity distribution (~5 common, ~3 rare, ~2 epic)
- Weighted random produces 3 unique talents per offer
- 500 XP threshold triggers talent pick
- pendingPicks tracks 0-3 queued picks
- currentOffer holds the 3 talents being offered
</success_criteria>

<output>
After completion, create `.planning/phases/05-talents-system/05-02-SUMMARY.md`
</output>
