---
phase: 11-autonomous-ai
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/autonomy.ts
  - src/utils/utilityScoring.ts
autonomous: true

must_haves:
  truths:
    - "Utility scoring factors are normalized to 0-100 scale"
    - "Scoring function computes weighted sum of need urgency, personality fit, and resource availability"
    - "Critical mode check identifies when any physiological need is below 15%"
  artifacts:
    - path: "src/types/autonomy.ts"
      provides: "AIDecision, DecisionLog, UtilityFactors types"
      exports: ["AIDecision", "DecisionLog", "UtilityFactors", "UtilityWeights"]
    - path: "src/utils/utilityScoring.ts"
      provides: "Utility scoring calculation functions"
      exports: ["calculateNeedUrgency", "calculateResourceAvailability", "calculateUtilityScore", "shouldOverrideToCriticalMode", "scoreInCriticalMode"]
  key_links:
    - from: "src/utils/utilityScoring.ts"
      to: "src/utils/curves.ts"
      via: "import needToMoodCurve"
      pattern: "import.*needToMoodCurve.*from.*curves"
    - from: "src/utils/utilityScoring.ts"
      to: "src/utils/personalityFit.ts"
      via: "import calculatePersonalityAlignment"
      pattern: "import.*calculatePersonalityAlignment.*from.*personalityFit"
---

<objective>
Create types and utility scoring functions for the autonomous AI system.

Purpose: Establish the foundational types and pure functions that compute utility scores for activity selection. These will be consumed by UtilityAIStore in Plan 02.

Output: Two new files - types/autonomy.ts with decision tracking types, and utils/utilityScoring.ts with scoring calculation functions.
</objective>

<execution_context>
@/Users/godstemning/.claude/get-shit-done/workflows/execute-plan.md
@/Users/godstemning/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-autonomous-ai/11-CONTEXT.md
@.planning/phases/11-autonomous-ai/11-RESEARCH.md

# Key existing files to reference
@src/utils/curves.ts
@src/utils/personalityFit.ts
@src/entities/Activity.ts
@src/entities/Character.ts
@src/entities/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create autonomy types</name>
  <files>src/types/autonomy.ts</files>
  <action>
Create the autonomy types file with:

1. `UtilityFactors` interface:
   - needUrgency: number (0-100)
   - personalityFit: number (0-100)
   - resourceAvailability: number (0-100)

2. `UtilityWeights` interface:
   - need: number (default 0.5)
   - personality: number (default 0.3)
   - resource: number (default 0.2)

3. `AIDecision` interface:
   - timestamp: number
   - activityId: string
   - activityName: string
   - topReason: string (e.g., "Eating because Hunger critical (12%)")
   - score: number
   - breakdown: UtilityFactors
   - topAlternatives: Array<{ activityId: string; activityName: string; score: number }>
   - criticalMode: boolean

4. `DecisionLog` type as Array<AIDecision> (last 5 decisions)

5. Export `DEFAULT_UTILITY_WEIGHTS` constant: { need: 0.5, personality: 0.3, resource: 0.2 }

Use JSDoc comments for all types explaining their purpose.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/types/autonomy.ts`</verify>
  <done>autonomy.ts exports UtilityFactors, UtilityWeights, AIDecision, DecisionLog, DEFAULT_UTILITY_WEIGHTS</done>
</task>

<task type="auto">
  <name>Task 2: Create utility scoring functions</name>
  <files>src/utils/utilityScoring.ts</files>
  <action>
Create utility scoring functions following RESEARCH.md patterns:

1. `shouldOverrideToCriticalMode(character: Character): boolean`
   - Return true if hunger < 15 OR bladder < 15 OR energy < 15
   - These are the physiological needs that trigger survival override

2. `calculateNeedUrgency(activity: Activity, character: Character): number`
   - Return 0 if activity has no needEffects
   - For each need in activity.needEffects:
     - Get current need value from character.needs[needKey]
     - Calculate urgency using inverted sigmoid: high urgency when need is low
     - Use needToMoodCurve from curves.ts (invert the result)
     - Formula: urgency = 50 - needToMoodCurve(currentValue, 1.0, 2.5)
     - Weight by restoration amount (restoration / 10, assume max restore ~10)
   - Return average urgency across all needs affected (0-100 scale)

3. `calculateResourceAvailability(activity: Activity, character: Character): number`
   - Get resource costs via activity.getResourceCosts(character)
   - Calculate ratio for each resource: current / max(1, cost)
   - overskuddRatio = character.actionResources.overskudd / max(1, costs.overskudd)
   - willpowerRatio = character.actionResources.willpower / max(1, costs.willpower)
   - focusRatio = costs.focus > 0 ? character.actionResources.focus / costs.focus : 1.0
   - socialRatio = costs.socialBattery > 0 ? character.actionResources.socialBattery / costs.socialBattery : 1.0
   - Return average of ratios * 100, clamped to 0-100

4. `calculatePersonalityFitScore(activity: Activity, character: Character): number`
   - Use calculatePersonalityAlignment from personalityFit.ts
   - alignment.gainMultiplier is 0.6-1.4 range
   - Convert to 0-100: (gainMultiplier - 0.6) / 0.8 * 100
   - Clamp result to 0-100

5. `scoreInCriticalMode(activity: Activity, character: Character): number`
   - Calculate pure urgency score (no personality)
   - For each need in activity.needEffects where character.needs[need] < 15:
     - urgencyScore += restoration * (15 - currentNeedValue)
   - Return urgencyScore (not normalized - higher is better)

6. `calculateUtilityScore(activity: Activity, character: Character, weights: UtilityWeights, isCurrentActivity: boolean): { score: number; factors: UtilityFactors }`
   - Calculate all three factors using above functions
   - Compute weighted sum: needUrgency * weights.need + personalityFit * weights.personality + resourceAvailability * weights.resource
   - If isCurrentActivity, apply 25% hysteresis bonus (score *= 1.25)
   - Clamp final score to 0-100
   - Return both score and factors breakdown

Import types from './types' and entities. Use explicit type imports.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit src/utils/utilityScoring.ts`</verify>
  <done>utilityScoring.ts exports all 6 functions with correct signatures and 0-100 normalized output</done>
</task>

</tasks>

<verification>
1. Both files compile without TypeScript errors
2. utilityScoring.ts correctly imports from curves.ts and personalityFit.ts
3. All exported functions have proper type signatures
</verification>

<success_criteria>
- Types defined in autonomy.ts match RESEARCH.md AIDecision structure
- Scoring functions return 0-100 normalized values (except scoreInCriticalMode)
- Critical mode check uses 15% threshold for hunger/bladder/energy
- Hysteresis bonus (25%) applied when isCurrentActivity is true
</success_criteria>

<output>
After completion, create `.planning/phases/11-autonomous-ai/11-01-SUMMARY.md`
</output>
